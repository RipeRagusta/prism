<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>House Call</title>
  <meta name="description" content="2d video game">
  <script src="//cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <link rel="shortcut icon" type="image" href="./assets/cultknifelogo.png">
  <style type="text/css">
    body {
      margin: 0;
      width: 100%;
      height: 100vh;
      height: 100dvh;
      background-color: black;
      overflow: hidden;
    }
  </style>
</head>
<body>

<script type="text/javascript">
  class playerBullet extends Phaser.Physics.Arcade.Sprite
  {
    constructor(scene, x, y, texture)
    {
      super(scene, x, y, texture);
      this.speed = 400;
      this.setActive(false);
      this.setVisible(false);
    }

    fire(x, y, angle)
    {
      this.originX = x;
      this.body.reset(x, y);
      this.setActive(true);
      this.setVisible(true);
      this.setRotation(angle);
      this.scene.physics.velocityFromRotation(angle, this.speed, this.body.velocity);
      this.body.allowGravity = false;
    }

    preUpdate(time, delta)
    {
      super.preUpdate(time, delta);

      if(this.y < 0 || this.y > this.scene.sys.game.config.height || this.x > this.originX + 200 || this.x < this.originX - 200)
      {
        this.setActive(false);
        this.setVisible(false);
        this.destroy();
      }
    }

    collided()
    {
      this.setActive(false);
      this.setVisible(false);
      this.destroy();
    }
  }

  class cultOrb extends Phaser.Physics.Arcade.Sprite
  {
    constructor(scene, x, y)
    {
      super(scene, x, y, 'cultorb');
      this.speed = 200;
      this.setActive(false);
      this.setVisible(false);
    }

    fire(x, y, angle)
    {
      this.body.reset(x, y);
      this.setActive(true);
      this.setVisible(true);
      this.setRotation(angle);
      this.scene.physics.velocityFromRotation(angle, this.speed, this.body.velocity);
      this.body.allowGravity = false;
      this.originX = x;
    }

    preUpdate(time, delta)
    {
      super.preUpdate(time, delta);

      if(this.y < 0 || this.y > this.scene.sys.game.config.height || this.x > this.originX + 1000 || this.x < this.originX - 1000)
      {
        this.setActive(false);
        this.setVisible(false);
        this.destroy();
      }
    }

    collided()
    {
      this.setActive(false);
      this.setVisible(false);
      this.destroy();
    }
  }
  
  /*class eyeOrb extends Phaser.Physics.Arcade.Sprite
  {
      constructor(scene, x, y)
    {
      super(scene, x, y, 'cultorb');
      this.speed = 200;
      this.setActive(false);
      this.setVisible(false);
    }

    fire(x, y, angle, playerMomentumX)
    {
      this.body.reset(x, y);
      this.setActive(true);
      this.setVisible(true);
      this.setRotation(angle);
      this.scene.physics.velocityFromRotation(angle, this.speed + playerMomentumX, this.body.velocity);
      this.body.allowGravity = false;
      this.originX = x;
    }

    preUpdate(time, delta)
    {
      super.preUpdate(time, delta);

      if(this.y < 0 || this.y > this.scene.sys.game.config.height || this.x > this.originX + 1000 || this.x < this.originX - 1000)
      {
        this.setActive(false);
        this.setVisible(false);
        this.destroy();
      }
    }

    collided()
    {
      this.setActive(false);
      this.setVisible(false);
      this.destroy();
    }
  }*/

  class cult extends Phaser.Physics.Arcade.Sprite
  {
    constructor(scene, x, y, player, cultOrbHolder)
    {
        super(scene, x, y, 'cult');

        scene.add.existing(this);
        scene.physics.add.existing(this);
        this.setActive(true);
        this.setVisible(true);
        this.health = 15;
        this.initialHealth = this.health;
        this.setBounce(0);
        this.player = player;
        this.alert = false;
        this.orbs = cultOrbHolder;
        this.distancePref = 100;
        this.initalDistancePref = this.distancePref;
        this.distanceOffset = 5;
        this.flip = false;
        this.scene = scene;
      
        if(!scene.anims.get('orbThrow'))
        {
            scene.anims.create
            ({
              key: 'orbThrow',
              frames: scene.anims.generateFrameNumbers('cult', { start: 2, end: 0 }),
              frameRate: 6,
              repeat: 0
            });
        }
        
        if(!scene.anims.get('cultOrbHurt'))
        {
            scene.anims.create
            ({
                key: 'cultOrbHurt',
                frames: [
                     { key: 'cult', frame: 3 },
                     { key: 'cult', frame: 0 }
                 ],
                frameRate: 2,
                repeat: 0
            });
        }
        
        this.bloodEmitter = this.scene.add.particles
        (
            0, 0, 
            'blood',
            {
                angle: { min: 0, max: 360 },
                speed: { min: 100, max: 200 },
                gravityY: 500,
                lifespan: { min: 750, max: 750 },
                quantity: 100,
                scale: { start: 0.5, end: 0 },
                alpha: { start: 1, end: 0 },
                blendMode: 'NORMAL',
                frequency: -1
            }
        );
    }

    preUpdate(time, delta)
    {
      super.preUpdate(time, delta);

      if(this.health < 1)
      {
        this.scene.sound.play('hurt');
        this.kill();
      }
      else
      {
        this.checkInRange();

        if(this.alert === true || this.health < this.initialHealth)
        {
          if(this.player.x < this.x && Math.abs(this.player.x - this.x) >= this.distancePref + this.distanceOffset)
          {
            this.setVelocityX(-110);
          }
          else if(this.player.x > this.x && Math.abs(this.player.x - this.x) >= this.distancePref + this.distanceOffset)
          {
            this.setVelocityX(110);
          }
          else if(Math.abs(this.player.x - this.x) >= this.distancePref - this.distanceOffset && Math.abs(this.player.x - this.x) <= this.distancePref + this.distanceOffset)
          {
            this.setVelocityX(0);
          }
          else
          {
            if (this.player.x < this.x)
            {
              this.setVelocityX(110);
            }
            else
            {
              this.setVelocityX(-110);
            }
          }

          if(this.x > this.player.x)
          {
            this.flip = false;
            this.setFlipX(false);
          }
          else
          {
            this.flip = true;
            this.setFlipX(true);
          }
        }
        else
        {
            if(this.flip === true)
            {
                this.setFlipX(true);
            }
            else
            {
                this.setFlipX(false);
            }
        }
      }
    }

    checkInRange()
    {
        if(this.alert === false && Math.abs(this.player.x - this.x) <= 200)
        {
            this.alert = true;
        }
    }
    
    shoot()
    {
        const orb = this.orbs.get(this.x, this.y, 'cultorb');

        if(orb)
        {
            if(this.flip === false)
            {
              orb.fire(this.x - (this.width / 2), this.y, Phaser.Math.DegToRad(180));
            }
            else
            {
              orb.fire(this.x - (this.width / 2), this.y, Phaser.Math.DegToRad(0));
            }

            this.play('orbThrow', false);
        }
    }
    
    buddha()
    {
        this.health = Number.MAX_SAFE_INTEGER;
    }
    
    kill()
    {
        this.bloodEmitter.setQuantity(100);
        this.bloodEmitter.emitParticleAt(this.x, this.y);
        //this.scene.sound.play('hurt');
        this.setActive(false);
        this.setVisible(false);
        this.destroy();
    }
  }

  class cultKnife extends Phaser.Physics.Arcade.Sprite
  {
    constructor(scene, x, y, player)
    {
        super(scene, x, y, 'cultknife');

        scene.add.existing(this);
        scene.physics.add.existing(this);
        this.setActive(true);
        this.setVisible(true);
        this.health = 5;
        this.setBounce(0);
        this.player = player;
        this.alert = false;
        this.flip = true;
        this.scene = scene;
      
        this.bloodEmitter = this.scene.add.particles
        (
            0, 0, 
            'blood',
            {
                angle: { min: 0, max: 360 }, 
                speed: { min: 100, max: 200 },
                gravityY: 500,
                lifespan: { min: 750, max: 750 },
                quantity: 75,
                scale: { start: 0.5, end: 0 },
                alpha: { start: 1, end: 0 },
                blendMode: 'NORMAL',
                frequency: -1
            }
        );
        
        if(!scene.anims.get('knifeidle'))
        {
          scene.anims.create
          ({
            key: 'knifeidle',
            frames: scene.anims.generateFrameNumbers('cultknife', { start: 0, end: 2 }),
            frameRate: 4,
            repeat: -1
          });
        }
        
        if(scene.anims.get('knifeidle'))
        {
            this.play('knifeidle');
        }
    }

    preUpdate(time, delta)
    {
      super.preUpdate(time, delta);

      if(this.health < 1)
      {
        this.scene.sound.play('hurt');
        this.kill();
      }
      else
      {
        this.checkInRange();

        if(this.alert === true || this.health < 5)
        {
          if(Math.abs(this.player.x - this.x) >= 0 - 5 && Math.abs(this.player.x - this.x) <= 0 + 5)
          {
            this.setVelocityX(0);
          }
          else
          {
            if(this.player.x < this.x)
            {
              this.setVelocityX(-150);
              this.flip = false;
              this.setFlipX(false);
            }
            else
            {
              this.setVelocityX(150);
              this.flip = true;
              this.setFlipX(true);
            }
          }
        }
        else
        {
            if(this.flip === true)
            {
              this.setFlipX(true);
            }
            else
            {
              this.setFlipX(false);
            }
        }
      }
    }

    checkInRange()
    {
      if(this.alert === false && Math.abs(this.player.x - this.x) <= 200)
      {
        this.alert = true;
      }
    }
    
    kill()
    {
        this.bloodEmitter.setQuantity(100);
        this.bloodEmitter.emitParticleAt(this.x, this.y);
        this.setActive(false);
        this.setVisible(false);
        this.destroy();
    }
  }

  class player extends Phaser.Physics.Arcade.Sprite
  {
    constructor(scene, x, y, playerBulletsHolder)
    {
        super(scene, x, y, 'player');

        scene.add.existing(this);
        scene.physics.add.existing(this);
        this.setActive(true);
        this.setVisible(true);
        this.flip = false;
        this.aimAngle = 0;
        this.fireRate = 750;
        this.baseFireRate = this.fireRate;
        this.doubleFire = false;
        this.doubleFireDuration = 1500;
        this.lastPlayerShot = 0;
        this.health = 10;
        this.setBounce(0);
        this.setCollideWorldBounds(true);
        this.scene = scene;
        this.lastPlayerBlock = 0;
        this.blockRate = 750;
        this.block = false;
        this.playerBulletsHolder = playerBulletsHolder;

        this.wasd =
        {
          space: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE),
          w: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),
          s: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),
          a: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),
          d: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D),
          shift: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT)
        };

        this.mouseRef = scene.input;
        this.bullets = playerBulletsHolder;

        if(!scene.anims.get('pump'))
        {
          scene.anims.create
          ({
            key: 'pump',
            frames: scene.anims.generateFrameNumbers('player', { start: 1, end: 0 }),
            frameRate: 6,
            repeat: 0
          });
        }
        
        if(!scene.anims.get('block'))
        {
          scene.anims.create
          ({
            key: 'block',
            frames: [
                     { key: 'player', frame: 2 },
                     { key: 'player', frame: 0 }
                    ],
            frameRate: 2,
            repeat: 0
          });
        }

        this.shellEmitter = this.scene.add.particles
        (
            0, 0, 
            'shell',
            {
                angle: 
                {
                    onEmit: () => 
                    {
                        if(this.flip === true)
                        {
                            return Phaser.Math.Between(-45, 45);
                        }
                        else
                        {
                            return  Phaser.Math.Between(135, 225);
                        }
                    }
                }, 
                speed: { min: 100, max: 200 },
                gravityY: 300,
                lifespan: { min: 1000, max: 1000 },
                quantity: 1,
                scale: { start: 1, end: 0.75 },
                alpha: { start: 1, end: 0.75 },
                blendMode: 'NORMAL',
                frequency: -1
            }
        );

        this.orbDestory = this.scene.add.particles
        (
            0, 0, 
            'bulletcult',
            {
                angle: 
                {
                    onEmit: () => 
                    {
                        if(this.flip === true)
                        {
                            return  Phaser.Math.Between(135, 225);
                        }
                        else
                        {
                            return Phaser.Math.Between(-45, 45);
                        }
                    }
                }, 
                speed: { min: 200, max: 200 },
                gravityY: 0,
                lifespan: { min: 1000, max: 1000 },
                quantity: 4,
                scale: { start: 1, end: 1 },
                alpha: { start: 1, end: 0 },
                blendMode: 'NORMAL',
                frequency: -1
            }
        );

        this.on(Phaser.GameObjects.Events.DESTROY, () => 
        {
            if(this.doubleFireTimer)
            {
                 this.doubleFireTimer.remove();
            }
        });
    }

    preUpdate(time, delta)
    {
      super.preUpdate(time, delta);

      if(this.health < 1)
      {
        this.setActive(false);
        this.setVisible(false);
        this.destroy();
      }
      
      this.checkBlock(time);

      if((this.wasd.a.isDown || this.scene.cursors.left.isDown))
      {
        this.setVelocityX(-120);
      }
      else if((this.wasd.d.isDown || this.scene.cursors.right.isDown))
      {
        this.setVelocityX(120);
      }
      else
      {
        this.setVelocityX(0);
      }

      if((this.wasd.space.isDown || this.wasd.w.isDown || this.scene.cursors.up.isDown) && this.body.touching.down)
      {
        this.setVelocityY(-120);
      }
      
      this.flipPlayer(this.scene.input.activePointer);
      this.scene.input.activePointer.updateWorldPoint(this.scene.cameras.main);
      this.updateAimAngle(this.scene.input.activePointer);

      if(this.mouseRef.activePointer.isDown && time > this.lastPlayerShot + this.fireRate && this.mouseRef.activePointer.leftButtonDown())
      {
        this.mouseRef.mouse.disableContextMenu();

        let offset = -12.5;

        for (let i = 0; i < 10; i++)
        {
          const bulletType = this.doubleFire ? 'bulletcult' : 'bullet';
          
          const bullet = this.bullets.get(this.x, this.y, bulletType);

          if(bullet)
          {
              if(this.flip === false)
              {
                bullet.fire(this.x + (this.width / 2) + (this.width / 16), this.y - (this.height / 32) - (this.height / 16), this.aimAngle + Phaser.Math.DegToRad(offset));
              }
              else
              {
                bullet.fire(this.x - (this.width / 2) - (this.width / 16), this.y - (this.height / 32) - (this.height / 16), this.aimAngle + Phaser.Math.DegToRad(offset));
              }
            offset += 2.5;
          }
        }

        this.lastPlayerShot = time;
        this.scene.sound.play('shotgunshot');
        this.play("pump", true);
        this.shellEmitter.emitParticleAt(this.x, this.y);
      }
      
      if(this.mouseRef.activePointer.isDown && time > this.lastPlayerBlock + this.blockRate && this.mouseRef.activePointer.rightButtonDown())
      {
          this.mouseRef.mouse.disableContextMenu();
          this.play("block", true);
          this.lastPlayerBlock = time;
      }
    }
    
    defenceParticles()
    {
        if(this.flip === false)
        {
            this.orbDestory.emitParticleAt(this.x + 6, this.y);
        }
        else
        {
             this.orbDestory.emitParticleAt(this.x - 6, this.y);
        }
    }
    
    checkBlock(time)
    {
        if(this.wasd.shift.isDown && time > this.lastPlayerBlock + this.blockRate)
        {
          this.play("block", true);

          this.lastPlayerBlock = time;
        }
      
        if(this.anims.isPlaying && this.anims.currentAnim.key === 'block' && this.anims.currentFrame.index === 1)
        {
            this.block = true;
        }
        else
        {
            this.block = false;
        }
    }

    flipPlayer(pointer)
    {
      if(pointer.worldX < this.getCenter().x)
      {
        this.setFlipX(true);
        this.flip = true;
      }
      else
      {
        this.setFlipX(false);
        this.flip = false;
      }
    }

    updateAimAngle(pointer)
    {
      if(this.flip === false)
      {
        this.aimAngle = Phaser.Math.Angle.Between
        (
          this.x + (this.width / 2) + (this.width / 16),
          this.y - (this.height / 32) - (this.height / 16),
          pointer.worldX,
          pointer.worldY
        );
      }
      else
      {
        this.aimAngle = Phaser.Math.Angle.Between
        (
          this.x - (this.width / 2) - (this.width / 16),
          this.y - (this.height / 32) - (this.height / 16),
          pointer.worldX,
          pointer.worldY
        );
      }
    }
    
    activateDoubleFire()
    {
        this.doubleFire = true;
        
        if(this.doubleFire === true)
        {
            this.fireRate = 325;
            this.scene.anims.get('pump').frameRate = 12;
        }
        
        if(this.doubleFireTimer)
        {
             this.doubleFireTimer.remove();
        }
        
        this.doubleFireTimer = this.scene.time.delayedCall(this.doubleFireDuration, () => 
        {
            this.doubleFire = false;
            this.fireRate = this.baseFireRate;
            this.scene.anims.get('pump').frameRate = 6;
        });
    }
    
    buddha()
    {
        this.health = Number.MAX_SAFE_INTEGER;
    }
  }

  class eye extends Phaser.Physics.Arcade.Sprite
  {
    constructor(scene, x, y, eyeOrbHolder)
    {
        super(scene, x, y, 'eye');

        scene.add.existing(this);
        scene.physics.add.existing(this);
        this.setActive(true);
        this.setVisible(true);
        this.setBounce(0);
        this.setCollideWorldBounds(true);
        this.body.setAllowGravity(false);
        this.body.allowGravity = false;
        this.health = 4;
        this.initialHealth = this.health;
        this.alert = false;
        this.scene = scene;
        this.player = this.scene.player;
        this.distancePref = 100;
        this.initalDistancePref = this.distancePref;
        this.distanceOffset = 5;
        this.orbs = eyeOrbHolder;

        this.explode = this.scene.add.particles
        (
            0, 0, 
            'eyechunk',
            {
                angle: { min: 0, max: 360 }, 
                speed: { min: 100, max: 200 },
                gravityY: 500,
                lifespan: { min: 750, max: 750 },
                quantity: 10,
                scale: { start: 0.5, end: 0 },
                alpha: { start: 1, end: 0 },
                blendMode: 'NORMAL',
                frequency: -1
            }
        );

        if(scene.ground)
        {
            scene.physics.add.collider(this, scene.ground);
        }
    }
    
    preUpdate(time, delta)
    {
        if(this.health < 1)
        {
            this.scene.sound.play('hurt');
            this.kill();
        }
        else
        {
            this.checkInRange();

            if(this.alert === true || this.health < this.initialHealth)
            {
              if(this.player.x < this.x && Math.abs(this.player.x - this.x) >= this.distancePref + this.distanceOffset)
              {
                this.setVelocityX(-110);
              }
              else if(this.player.x > this.x && Math.abs(this.player.x - this.x) >= this.distancePref + this.distanceOffset)
              {
                this.setVelocityX(110);
              }
              else if(Math.abs(this.player.x - this.x) >= this.distancePref - this.distanceOffset && Math.abs(this.player.x - this.x) <= this.distancePref + this.distanceOffset)
              {
                this.setVelocityX(0);
              }
              else
              {
                if (this.player.x < this.x)
                {
                  this.setVelocityX(110);
                }
                else
                {
                  this.setVelocityX(-110);
                }
              }

              if(this.x > this.player.x)
              {
                this.flip = false;
              }
              else
              {
                this.flip = true;
              }
            }
        }
    }
    
    shoot()
    {
        const orb = this.orbs.get(this.x, this.y, 'cultorb');

        if(orb)
        {
            orb.fire(this.x, this.y, Phaser.Math.Angle.Between(this.x, this.y, this.player.x, this.player.y));
        }
    }
    
    checkInRange()
    {
        if(this.alert === false && Math.abs(this.player.x - this.x) <= 200)
        {
            this.alert = true;
        }
    }
    
    kill()
    {
        this.explode.emitParticleAt(this.x, this.y);
        this.destroy();
    }
}

  class pipeNext extends Phaser.Physics.Arcade.Sprite
  {
      constructor(scene, x, y, key) 
      {
        super(scene, x, y, 'pipe');
        
        this.pipe = scene.physics.add.sprite(x, y, 'pipe');
        this.pipe.setOrigin(0, 1);
        this.pipe.body.allowGravity = false;
        this.pipe.body.setImmovable(true);
        scene.physics.add.collider(this.pipe, this.ground);
        
        if(!scene.anims.get('stabAnim'))
        {
            scene.anims.create
            ({
                key: "stabAnim",
                frames: this.anims.generateFrameNumbers('stab', {start: 0, end: 2 }),
                frameRate: 2,
                repeat: 0
            });
        }
        scene.stab = scene.add.sprite(this.pipe.x, this.pipe.y, "stab").setOrigin(0, 1);
        scene.stab.setActive(false);
        scene.stab.setVisible(false);
        
        scene.physics.add.collider(this.pipe, scene.player, (pipe, player) =>
        {
          player.destroy();
          scene.stab.setActive(true);
          scene.stab.setVisible(true);
          scene.sound.play('powerup');
          
          scene.stab.on(Phaser.Animations.Events.ANIMATION_UPDATE, (anim, frame) => 
            {
                if(frame.index === 2) 
                {
                    let aCultActive = false;
                    scene.sound.play('stab');
                    
                    if(scene.cults && scene.cults.children.entries)
                    {
                        const cultsArray = scene.cults.children.entries; 
                        
                        for(let i = cultsArray.length - 1; i >= 0; i--) 
                        {
                            const cult = cultsArray[i];
                            aCultActive = true;
                            cult.kill();  
                        }
                    }
                    
                    if(scene.cultKnifes && scene.cultKnifes.children.entries)
                    {
                        const cultKnifesArray = scene.cultKnifes.children.entries; 
                        
                        for(let i = cultKnifesArray.length - 1; i >= 0; i--) 
                        {
                            const cultKnife = cultKnifesArray[i];
                            aCultActive = true;
                            cultKnife.kill();  
                        }
                    }
                    
                    if(scene.eyes && scene.eyes.children.entries)
                    {
                        const eyesArray = scene.eyes.children.entries; 
                        
                        for(let i = eyesArray.length - 1; i >= 0; i--) 
                        {
                            const eye = eyesArray[i];
                            aCultActive = true;
                            eye.kill();  
                        }
                    }
                    
                    if(aCultActive)
                    {
                        scene.sound.play('hurt');
                    }
                }
            });
        
          scene.stab.play("stabAnim", true);
        });
        
        scene.stab.on(Phaser.Animations.Events.ANIMATION_COMPLETE, () => 
        {
          scene.scene.start(key);
        });
      }
  }

  class Loading extends Phaser.Scene
  {
    constructor()
    {
      super({key: 'Loading'});
    }

    preload()
    {
        this.load.image('sky', 'assets/sky.png');
        this.load.spritesheet('player', 'assets/player.png', {frameWidth: 16, frameHeight: 16});
        this.load.image('ground', 'assets/grass.png');
        this.load.image('bullet', 'assets/bullet.png');
        this.load.image('barn', 'assets/barn.png');
        this.load.image('fence', 'assets/fence.png');
        this.load.image('stars', 'assets/stars.png');
        this.load.image('cross', 'assets/cross.png');
        this.load.spritesheet('cult', './assets/cult.png', {frameWidth: 16, frameHeight: 16});
        this.load.image('couch', './assets/couch.png');
        this.load.image('tractor', './assets/tractor.png');
        this.load.image('grasstop', './assets/grasstop.png');
        this.load.image('grill', './assets/grill.png');
        this.load.spritesheet('cultknife', './assets/cultknife.png', {frameWidth: 16, frameHeight: 16});
        this.load.image('copcar', './assets/copcar.png');
        this.load.image('cultorb', './assets/cultorb.png');
        this.load.image('wheat', './assets/wheat.png');
        this.load.image('shed', './assets/shed.png');
        this.load.image('silo', './assets/silo.png');
        this.load.image('scarecrow', './assets/scarecrow.png');
        this.load.image('pipe', './assets/pipe.png');
        this.load.image('eye', './assets/eye.png');
        this.load.spritesheet('stab', './assets/stab.png', {frameWidth: 12, frameHeight: 18});
        this.load.image('blood', 'assets/bloodparticle.png');
        this.load.image('eyechunk', 'assets/eyechunk.png');
        this.load.image('shell', 'assets/shell.png');
        this.load.image('raindrop', 'assets/raindrop.png');
        this.load.image('bloodrain', 'assets/bloodrain.png');
        this.load.image('redsky', 'assets/redsky.png');
        this.load.image('redskyrain', 'assets/redskyrain.png');
        this.load.image('bulletcult', 'assets/bulletcult.png');

        this.load.audio('shotgunshot', 
        [
            'assets/shotgunshot.wav'
        ]);
        
        this.load.audio('orbthrow', 
        [
            'assets/orbthrow.wav'
        ]);
        
        this.load.audio('hurt', 
        [
            'assets/hurt.wav'
        ]);
        
        this.load.audio('powerup', 
        [
            'assets/powerup.wav'
        ]);
        
        this.load.audio('block', 
        [
            'assets/block.wav'
        ]);
        
        this.load.audio('stab', 
        [
            'assets/stab.wav'
        ]);
        
        this.load.audio('eyeorb', 
        [
            'assets/eyeorb.wav'
        ]);
    }

    create()
    {
      this.levelSelect = this.add.text((this.sys.game.config.width / 2), this.sys.game.config.height / 2, 'Loading', { fontSize: '16px', fill: '#fff' }).setOrigin(0.5);
    }

    update()
    {
      this.scene.start('MainMenu');
    }
  }

  class MainMenu extends Phaser.Scene
  {
    constructor()
    {
      super({key: 'MainMenu'});
    }

    preload()
    {

    }

    create ()
    {
        //START BASIC SETUP MainMenu


        const worldWidthX = this.sys.game.config.width * 3;
        this.physics.world.setBounds(0, 0, worldWidthX / 3, 176);
        this.cursors = this.input.keyboard.createCursorKeys();


        //END BASIC SETUP MainMenu


        //START PROPS BEFORE PLAYER MainMenu
        

        this.sky = this.add.tileSprite(0, 0, worldWidthX, this.sys.game.config.height, 'sky').setOrigin(0, 0);
        this.sky.setScrollFactor(0.1);

        this.stars = this.add.tileSprite(0, 0, worldWidthX, this.sys.game.config.height, 'stars').setOrigin(0, 0);
        this.stars.setScrollFactor(0.1);
        
        this.ground = this.add.tileSprite
        (
          0,
          this.sys.game.config.height,
          worldWidthX * 2,
          16,
          'ground'
        );

        this.ground.setOrigin(0, 1);
        this.physics.add.existing(this.ground);
        this.ground.body.setImmovable(true);
        this.ground.body.allowGravity = false;
        
        this.barn = this.add.image
        (
          (worldWidthX / 3) / 30,
          this.sys.game.config.height - this.ground.height,
          'barn'
        ).setOrigin(0, 1);
        this.barn.setTint(0x999999);
        this.barn.setScrollFactor(0.25);
        
        this.silo = this.add.image
        (
          this.barn.width + (worldWidthX / 3) / 30,
          this.sys.game.config.height - this.ground.height,
          'silo'
        );
        this.silo.setOrigin(0, 1);
        this.silo.setScrollFactor(0.225);
        
        this.cross = this.add.image
        (
          (worldWidthX / 3) + ((worldWidthX / 3) / 30),
          this.sys.game.config.height - this.ground.height,
          'cross'
        );
        this.cross.setOrigin(0, 1);
        this.cross.setScrollFactor(0.25);
        this.cross.setTint(0x999999);

        this.fence = this.add.tileSprite
        (
                this.sys.game.config.width / 2,
                this.sys.game.config.height - this.ground.height,
                worldWidthX,
                16,
                'fence'
        );
        this.fence.setScrollFactor(0.75);
        this.fence.setOrigin(0.25, 1);


        //END PROPS BEFORE PLAYER MainMenu
      
      
        //START PLAYER SETUP MainMenu


        createPlayer(this, Math.min(94, this.sys.game.config.width / 2), this.sys.game.config.height - 24);
        this.player.buddha();


        //END PLAYER SETUP MainMenu
      
      
        //START ENEMY SETUP MainMenu
        
      
        const cultPositions = 
        [
            { x: worldWidthX / 2, y: 100 }
        ];
        
        cultCreator(this, cultPositions);
        
        this.cults.children.entries.forEach(cult => 
        {
            cult.buddha();
        });
        
        
        //END ENEMY SETUP MainMenu
      
        
        //START PROPS AFTER PLAYER MainMenu
        
        
        this.copcar = this.add.image
        (
          worldWidthX / 4 + this.sys.game.config.width / 4 - this.sys.game.config.width / 8,
          this.sys.game.config.height - this.ground.height,
          'copcar'
        ).setOrigin(1, 1);
        
        this.pipe = this.physics.add.sprite(worldWidthX / 2 + this.sys.game.config.width / 4 - 8, this.sys.game.config.height - this.ground.height, 'pipe');
        this.pipe.setOrigin(0, 1);
        this.pipe.body.allowGravity = false;
        this.pipe.body.setImmovable(true);
        this.physics.add.collider(this.pipe, this.ground);
        
        if(!this.anims.get('stabAnim'))
        {
            this.anims.create
            ({
                key: "stabAnim",
                frames: this.anims.generateFrameNumbers('stab', {start: 0, end: 2 }),
                frameRate: 2,
                repeat: 0
            });
        }
        this.stab = this.add.sprite(this.pipe.x, this.pipe.y, "stab").setOrigin(0, 1);
        this.stab.setActive(false);
        this.stab.setVisible(false);
        
        this.physics.add.collider(this.pipe, this.player, (pipe, player) =>
        {
          player.destroy();
          this.stab.setActive(true);
          this.stab.setVisible(true);
          this.sound.play('powerup');
          
          this.stab.on(Phaser.Animations.Events.ANIMATION_UPDATE, (anim, frame) => 
            {
                if(frame.index === 2) 
                {
                    this.sound.play('stab');
                    
                    this.cults.children.entries.forEach(cult => 
                    {
                        cult.health = -100;
                    });
                    
                    this.controls.destroy();
                    this.strafeControls.destroy();
                    this.jumpControls.destroy();
                    this.leftClickControls.destroy();
                    this.rightClickControls.destroy();
                }
            });
        
            this.stab.play("stabAnim", true);
        });
        
        this.stab.on(Phaser.Animations.Events.ANIMATION_COMPLETE, () => 
        {
          this.cameras.main.pan(worldWidthX, this.sys.game.config.height / 2, 2000, 'Sine.easeInOut');
        });
        
        this.grasstop = this.add.tileSprite
        (
          0,
          this.sys.game.config.height - this.ground.height,
          worldWidthX,
          16,
          'grasstop'
        );
        this.grasstop.setOrigin(0, 1);
     
        this.logo = this.createText(this, worldWidthX / 6, this.sys.game.config.height / 2, 'House Call', 16).setOrigin(0.5, 0.5);
        this.logo.setInteractive({cursor: 'pointer'});
      
        this.physics.add.existing(this.logo, true);
        this.physics.add.collider(this.logo, this.playerBulletsHolder, (logo, bullet) =>
        {
          bullet.destroy();
          logo.destroy();
          this.cameras.main.pan(worldWidthX / 2, this.sys.game.config.height / 2, 2000, 'Sine.easeInOut');
          
            this.time.delayedCall(2000, () =>
            {
                this.player.x = worldWidthX / 3 - this.player.width / 2;
                this.tweens.add
                ({
                    targets: this.player, 
                    x: worldWidthX / 3 + this.player.width / 2,               
                    y: this.sys.game.config.height - 24,               
                    duration: 250,       
                    ease: 'linear',       
                    onComplete: () => 
                    {
                        this.physics.world.setBounds(this.sys.game.config.width, 0, this.sys.game.config.width, 176);
                    }
                });
            }, [], this);
            
        });
        
        this.controls = this.createText(this, worldWidthX / 2, 10, 'Controls:', 16);
        
        this.strafeControls = this.createText(this, worldWidthX / 2, 0 + this.controls.height + 20, 'A/D, ←/→: Strafe', 12);
        this.jumpControls = this.createText(this, worldWidthX / 2, 0 + this.controls.height + this.strafeControls.height + 25, 'W, Space, ↑: Jump', 12);
        this.rightClickControls = this.createText(this, worldWidthX / 2, 0 + this.controls.height + this.strafeControls.height + this.jumpControls.height + 30, 'Right-Click, L-Shift: Block', 12);
        this.leftClickControls = this.createText(this, worldWidthX / 2, 0 + this.controls.height + this.strafeControls.height + this.jumpControls.height + this.rightClickControls.height + 35, 'Left-Click: Shoot', 12);
        
        this.start = this.createText(this, worldWidthX - this.sys.game.config.width / 2, this.sys.game.config.height / 2, 'Start', 16).setOrigin(0.5, 0.5);
        this.start.setInteractive({cursor: 'pointer'});
        this.start.on('pointerdown', () =>
        {
          this.scene.stop('MainMenu');
          this.scene.start('Level1Game');
        });
        
        
        //END PROPS AFTER PLAYER MainMenu
        
        
        //START CAMERA SETUP MainMenu
        
        
        this.cameras.main.setBounds(0, 0, worldWidthX, 176);
        //this.cameras.main.startFollow(this.player, true, 1, 1, 0, (this.sys.game.config.height / 2));
        this.cameras.main.setZoom(1);
        
        
        //END CAMERA SETUP MainMenu
    }

    update(time)
    {
        if(this.player.health < 1000)
        {
            this.player.buddha();
        }
    }
    
    createText(scene, x, y, words, size)
    {
        let newText = scene.add.text(x, y, words, { fontSize: size, fill: '#fff'}).setOrigin(0.5, 0);
        return newText;
    }
  }
  
  function createLevelProps(scene)
  {
    scene.shed = scene.add.image(75, scene.sys.game.config.height - scene.ground.height, 'shed');
    scene.shed.setOrigin(0, 1);
    scene.shed.setScrollFactor(0.65);

    scene.fence = scene.add.tileSprite
    (
      0,
      scene.sys.game.config.height - scene.ground.height,
      148,
      16,
      'fence'
    );
    scene.fence.setScrollFactor(0.75);
    scene.fence.setOrigin(0, 1);

    scene.couch = scene.add.image(45, scene.sys.game.config.height - scene.ground.height, 'couch');
    scene.couch.setScrollFactor(0.8);
    scene.couch.setOrigin(0, 1);

    scene.grill = scene.add.image(15, scene.sys.game.config.height - scene.ground.height, 'grill');
    scene.grill.setScrollFactor(0.8);
    scene.grill.setOrigin(0, 1);
  }
  
  function createPlayer(scene, x, y)
  {
        scene.playerBulletsHolder = scene.physics.add.group
        ({
          classType: playerBullet,
          maxSize: 60,
          runChildUpdate: true
        });

        scene.player = new player(scene, 32, scene.sys.game.config.height - 24, scene.playerBulletsHolder);
        
        if(scene.ground)
        {
            scene.physics.add.collider(scene.player, scene.ground);
        }
  }

  function cultSeparation(cults, player)
  {
    let cultsWithDistancesRight = [];
    let cultsWithDistancesLeft = [];

    cults.children.entries.forEach(cult =>
    {
      let distance = Phaser.Math.Distance.Between(player.x, player.y, cult.x, cult.y);

      if(player.x < cult.x)
      {
        cultsWithDistancesRight.push
        ({
            cult: cult,
            distance: distance
        });
      }
      else
      {
        cultsWithDistancesLeft.push
        ({
            cult: cult,
            distance: distance
        });
      }
    });

    cultsWithDistancesRight.sort((a, b) =>
    {
      return a.distance - b.distance;
    });

    cultsWithDistancesLeft.sort((a, b) =>
    {
      return a.distance - b.distance;
    });

    let newDistanceAdderRight = 0;
    cultsWithDistancesRight.forEach(item =>
    {
      item.cult.distancePref = item.cult.initalDistancePref + newDistanceAdderRight;
      newDistanceAdderRight += 16;
    });

    let newDistanceAdderLeft = 0;
    cultsWithDistancesLeft.forEach(item =>
    {
      item.cult.distancePref = item.cult.initalDistancePref + newDistanceAdderLeft;
      newDistanceAdderLeft += 16;
    });
  }
  
  function cultSynchro(scene, cults)
  {
        let aCultAcvite = false;
        
        cults.children.entries.forEach(cult => 
        {
            if(cult.alert && cult.visible) 
            {
                cult.shoot();
                
                if(!aCultAcvite)
                {
                    aCultAcvite = !aCultAcvite;
                }
            }
        });
        
        if(aCultAcvite)
        {
            scene.sound.play('orbthrow');
        }
  }
  
  function cultCreator(scene, cultPositions)
  {
        scene.cultOrbHolder = scene.physics.add.group
        ({
          classType: cultOrb,
          maxSize: 30,
          runChildUpdate: true
        });
        scene.physics.add.collider(scene.player, scene.cultOrbHolder, (player, orb) =>
        {
            if(!player.block)
            {
                player.health -= 10;
            }
            else
            {
                scene.sound.play('block');
                player.defenceParticles();
                player.activateDoubleFire();
            }
            orb.destroy();
        });
        
        scene.cults = scene.physics.add.group();
      
        cultPositions.forEach(pos => 
        {
            const cultInstance = new cult(scene, pos.x, pos.y, scene.player, scene.cultOrbHolder);
            scene.cults.add(cultInstance);
        });
        
        if(scene.ground)
        {
            scene.physics.add.collider(scene.cults, scene.ground);
        }
        scene.physics.add.collider(scene.cults, scene.cults);
        scene.physics.add.overlap(scene.cults, scene.playerBulletsHolder, (cult, bullet) =>
        {
          cult.health -= 1;
          bullet.destroy();
          if(!cult.anims.isPlaying)
          {
            cult.play("cultOrbHurt", false);
          }
          cult.bloodEmitter.setQuantity(4);
          cult.bloodEmitter.emitParticleAt(cult.x, cult.y);
        });
        
        scene.time.addEvent
        ({
            delay: 1500,
            callback: () => cultSynchro(scene, scene.cults),
            callbackScope: this,
            loop: true
        });
  }
  
  function cultKnifeCreator(scene, cultKnifePositions)
  {     
        scene.cultKnifes = scene.physics.add.group();
      
        cultKnifePositions.forEach(pos => 
        {
            const cultKnifeInstance = new cultKnife(scene, pos.x, pos.y, scene.player);
            scene.cultKnifes.add(cultKnifeInstance);
        });
        
        if(scene.ground)
        {
            scene.physics.add.collider(scene.cultKnifes, scene.ground);
        }
        
        scene.physics.add.overlap(scene.cultKnifes, scene.playerBulletsHolder, (cult, bullet) =>
        {
          cult.health -= 1;
          bullet.destroy();
          cult.bloodEmitter.setQuantity(4);
          cult.bloodEmitter.emitParticleAt(cult.x, cult.y);
        });
        
        scene.physics.add.collider(scene.player, scene.cultKnifes, (player, cult) =>
        {
          player.health -= 10;
        });
        
        scene.physics.add.collider(scene.cultKnifes, scene.cultKnifes);
  }
  
  function eyeCreator(scene, eyePositions)
  {
        scene.eyeOrbHolder = scene.physics.add.group
        ({
          classType: cultOrb,
          maxSize: 30,
          runChildUpdate: true
        });
        scene.physics.add.collider(scene.player, scene.eyeOrbHolder, (player, orb) =>
        {
          if(!player.block)
          {
              player.health -= 10;
          }
          else
          {
              scene.sound.play('block');
              player.defenceParticles();
              player.activateDoubleFire();
          }
          orb.destroy();
        });
        
        scene.eyes = scene.physics.add.group
        ({
            immovable: true,
            allowGravity: false
        });

        eyePositions.forEach(pos =>
        {
            const eyeInstance = new eye(scene, pos.x, pos.y, scene.eyeOrbHolder);
            scene.eyes.add(eyeInstance);
        });

        if(scene.ground)
        {
            scene.physics.add.collider(scene.cultKnifes, scene.ground);
        }
        
        scene.physics.add.overlap(scene.eyes, scene.playerBulletsHolder, (eye, bullet) =>
        {
          eye.health -= 1;
          bullet.destroy();
        });
        
        scene.time.addEvent
        ({
            delay: 1500,
            callback: () => eyeSynchro(scene, scene.eyes),
            callbackScope: this,
            loop: true
        });
  }
  
  function eyeSeparation(eyes, player)
  {
    let eyesWithDistancesRight = [];
    let eyesWithDistancesLeft = [];

    eyes.children.entries.forEach(eye =>
    {
      let distance = Phaser.Math.Distance.Between(player.x, player.y, eye.x, eye.y);

      if(player.x < eye.x)
      {
        eyesWithDistancesRight.push
        ({
            eye: eye,
            distance: distance
        });
      }
      else
      {
        eyesWithDistancesLeft.push
        ({
            eye: eye,
            distance: distance
        });
      }
    });

    eyesWithDistancesRight.sort((a, b) =>
    {
      return a.distance - b.distance;
    });

    eyesWithDistancesLeft.sort((a, b) =>
    {
      return a.distance - b.distance;
    });

    let newDistanceAdderRight = 0;
    eyesWithDistancesRight.forEach(item =>
    {
      item.eye.distancePref = item.eye.initalDistancePref + newDistanceAdderRight;
      newDistanceAdderRight += 32;
    });

    let newDistanceAdderLeft = 0;
    eyesWithDistancesLeft.forEach(item =>
    {
      item.eye.distancePref = item.eye.initalDistancePref + newDistanceAdderLeft;
      newDistanceAdderLeft += 32;
    });
  }
  
  function eyeSynchro(scene, eyes)
  {
        let anEyeAcvite = false;
        
        eyes.children.entries.forEach(eye => 
        {
            if(eye.alert && (eye.visible))
            {
                eye.shoot();
                
                if(!anEyeAcvite)
                {
                    anEyeAcvite = !anEyeAcvite;
                }
            }
        });
        
        if(anEyeAcvite)
        {
            scene.sound.play('eyeorb');
        }
  }
  
  function makeRain(scene, texture)
  {
        scene.rain = scene.add.particles
        (
            0, 0, 
            texture,
            {
                x: { min: 0, max: scene.sys.game.config.width + (scene.sys.game.config.width / 5) },
                y: { min: -15, max:-7 },
                angle: { min: 90, max: 180 }, 
                speed: { min: 100, max: 300 },
                gravityY: 100,
                lifespan: { min: 1500, max: 1500 },
                quantity: 15,
                scale: { start: 0.35, end: 0.25 },
                alpha: { start: 1, end: 0 },
                blendMode: 'NORMAL',
                frequency: 50
            }
        );

        scene.rain.start();
        scene.rain.setScrollFactor(0);
  }
  
  function filterColors(scene, color)
  {
        if(scene.shed)
        {
            scene.shed.setTint(color);
        }
        if(scene.fence)
        {
            scene.fence.setTint(color);
        }
        if(scene.couch)
        {
            scene.couch.setTint(color);
        }
        if(scene.grill)
        {
            scene.grill.setTint(color);
        }
        if(scene.ground)
        {
            scene.ground.setTint(color);
        }
        if(scene.grasstop)
        {
            scene.grasstop.setTint(color);
        }
        if(scene.wheat)
        {
            scene.wheat.setTint(color);
        }
  }

  class Level1Game extends Phaser.Scene
  {
    constructor()
    {
      super({ key: 'Level1Game' });
    }

    preload()
    {

    }

    create()
    {
        //START BASIC SETUP Level1Game


        const worldWidthX = 1800;
        this.physics.world.setBounds(0, 0, worldWidthX, 176);
        this.cursors = this.input.keyboard.createCursorKeys();


        //END BASIC SETUP Level1Game


        //START PROPS BEFORE PLAYER Level1Game
        

        this.sky = this.add.tileSprite(0, 0, worldWidthX, this.sys.game.config.height, 'sky').setOrigin(0, 0);
        this.sky.setScrollFactor(0.1);

        this.stars = this.add.tileSprite(0, 0, worldWidthX, this.sys.game.config.height, 'stars').setOrigin(0, 0);
        this.stars.setScrollFactor(0.1);

        this.scarecrow = this.add.image(500, this.sys.game.config.height - 16, 'scarecrow').setOrigin(0, 1);
        this.scarecrow.setScrollFactor(0.4);

        this.wheat = this.add.tileSprite
        (
            0,
            176 - 16,
            worldWidthX,
            16,
            'wheat'
        );
        this.wheat.setOrigin(0, 1);
        this.wheat.setScrollFactor(0.575);

        this.ground = this.add.tileSprite
        (
          0,
          this.sys.game.config.height,
          worldWidthX * 2,
          16,
          'ground'
        );

        this.ground.setOrigin(0, 1);
        this.physics.add.existing(this.ground);
        this.ground.body.setImmovable(true);
        this.ground.body.allowGravity = false;

        createLevelProps(this);


        //END PROPS BEFORE PLAYER Level1Game
      
      
        //START PLAYER SETUP Level1Game

        
        createPlayer(this, 32, this.sys.game.config.height - 24);


        //END PLAYER SETUP Level1Game
      
      
        //START ENEMY SETUP Level1Game
        
        const cultPositions = 
        [
            { x: 750, y: 100 },
            { x: 1050, y: 100 },
            { x: 1100, y: 100 }
        ];
        
        cultCreator(this, cultPositions);
        
        const cultKnifePositions = 
        [
            { x: 500, y: 100 },
            { x: 625, y: 100 },
            { x: 650, y: 100 },
            { x: 1000, y: 100 }
        ];
        
        cultKnifeCreator(this, cultKnifePositions);
        
        const eyePositions = 
        [
            //{ x: 200, y: 100 },
            //{ x: 200, y: 100 }
        ];
        
        eyeCreator(this, eyePositions);
        
        //this.eyes = new eye(this, 200, this.sys.game.config.height - 24);
        //END ENEMY SETUP Level1Game
      
        
        //START PROPS AFTER PLAYER Level1Game
        
        
        this.pipe = new pipeNext(this, 1600, this.sys.game.config.height - this.ground.height, 'Level2Game');

        this.grasstop = this.add.tileSprite
        (
          0,
          this.sys.game.config.height - this.ground.height,
          worldWidthX,
          16,
          'grasstop'
        );
        this.grasstop.setOrigin(0, 1);
        
        this.tractor = this.physics.add.sprite(200, this.sys.game.config.height - this.ground.height, 'tractor');
        this.tractor.setOrigin(0, 1);
        this.tractor.body.allowGravity = false;
        this.tractor.body.setImmovable(true);

        this.physics.add.collider(this.tractor, this.ground);
        this.physics.add.collider(this.tractor, this.player);
        
        
        //END PROPS AFTER PLAYER Level1Game
        
        
        //START CAMERA SETUP Level1Game
        
        
        this.cameras.main.setBounds(0, 0, worldWidthX, 176);
        this.cameras.main.startFollow(this.player, true, 1, 1, 0, (this.sys.game.config.height / 2));
        this.cameras.main.setZoom(1);
        
        
        //END CAMERA SETUP Level1Game
    }

    update(time, delta)
    {
      if(this.player.health < 1)
      {
        this.scene.stop('Level1Game');
        this.scene.start('Level1Game');
      }

      cultSeparation(this.cults, this.player);
      //eyeSeparation(this.eyes, this.player);
    }
  }

  class Level2Game extends Phaser.Scene
  {
    constructor()
    {
      super({ key: 'Level2Game' });
    }

    preload()
    {

    }

    create()
    {
        //START BASIC SETUP Level2Game


        const worldWidthX = 2200;
        this.physics.world.setBounds(0, 0, worldWidthX, 176);
        this.cursors = this.input.keyboard.createCursorKeys();


        //END BASIC SETUP Level2Game


        //START PROPS BEFORE PLAYER Level2Game


        this.sky = this.add.tileSprite(0, 0, worldWidthX, this.sys.game.config.height, 'sky').setOrigin(0, 0);
        this.sky.setScrollFactor(0.1);
        this.sky.postFX.addColorMatrix().grayscale(1);
        
        this.scarecrow = this.add.image(400, this.sys.game.config.height - 16, 'scarecrow').setOrigin(0, 1);
        this.scarecrow.setScrollFactor(0.4);
        
        this.wheat = this.add.tileSprite
        (
            0,
            176 - 16,
            worldWidthX,
            16,
            'wheat'
        );
        this.wheat.setOrigin(0, 1);
        this.wheat.setScrollFactor(0.575);

        this.ground = this.add.tileSprite
        (
            -worldWidthX,
            this.sys.game.config.height,
            worldWidthX * 3,
            16,
            'ground'
        );

        this.ground.setOrigin(0, 1);
        this.physics.add.existing(this.ground);
        this.ground.body.setImmovable(true);
        this.ground.body.allowGravity = false;
        this.ground.setTint(0xd1e0e0);

        //createLevelProps(this);
        
        this.grill = this.add.image(15, this.sys.game.config.height - this.ground.height, 'pipe');
        this.grill.setScrollFactor(0.8);
        this.grill.setOrigin(0, 1);
       
        
        //END PROPS BEFORE PLAYER Level2Game


        //START PLAYER SETUP Level2Game


        createPlayer(this, 32, this.sys.game.config.height - 24);
        

        //END PLAYER SETUP Level2Game


        //START ENEMY SETUP Level2Game


        const cultPositions = 
        [
            { x: 500, y: 100 },
            { x: 500, y: 100 },
            { x: 1000, y: 100 },
            { x: 1000, y: 100 },
            { x: 1500, y: 100 },
            { x: 1500, y: 100 },
            { x: 1500, y: 100 },
            { x: 1500, y: 100 },
            { x: 1500, y: 100 }
        ];
        
        cultCreator(this, cultPositions);
        
        const cultKnifePositions = 
        [
            { x: -150, y: 100 }
        ];
        
        cultKnifeCreator(this, cultKnifePositions);


        //END ENEMY SETUP Level2Game
        

        //START PROPS AFTER PLAYER Level2Game
        

        this.pipe = new pipeNext(this, 1950, this.sys.game.config.height - this.ground.height, 'Level3Game');

        this.grasstop = this.add.tileSprite
        (
            0,
            this.sys.game.config.height - this.ground.height,
            worldWidthX,
            16,
            'grasstop'
        );
        this.grasstop.setOrigin(0, 1);

        this.physics.add.collider(this.player, this.ground);
        
        makeRain(this, 'raindrop');
        
        filterColors(this, 0xd1e0e0);
        
        
        //END PROPS AFTER PLAYER Level2Game


        //START CAMERA SETUP Level2Game


        this.cameras.main.setBounds(0, 0, worldWidthX, 176);
        this.cameras.main.startFollow(this.player, true, 1, 1, 0, (this.sys.game.config.height / 2));
        this.cameras.main.setZoom(1);


        //END CAMERA SETUP Level2Game
    }

    update(time, delta)
    {
        if(this.player.health < 1)
        {
            this.scene.stop('Level2Game');
            this.scene.start('Level1Game');
        }

        cultSeparation(this.cults, this.player);
        //eyeSeparation(this.eyes, this.player);
    }
  }


  class Level3Game extends Phaser.Scene
  {
    constructor()
    {
      super({key: 'Level3Game'});
    }

    create()
    {
        //START BASIC SETUP Level3Game


        const worldWidthX = 1650;
        this.physics.world.setBounds(0, 0, worldWidthX, 176);
        this.cursors = this.input.keyboard.createCursorKeys();


        //END BASIC SETUP Level3Game


        //START PROPS BEFORE PLAYER Level3Game


        this.sky = this.add.tileSprite(0, 0, worldWidthX, this.sys.game.config.height, 'redskyrain').setOrigin(0, 0);
        this.sky.setScrollFactor(0.1);
        
        this.scarecrow = this.add.image(700, this.sys.game.config.height - 16, 'scarecrow').setOrigin(0, 1);
        this.scarecrow.setScrollFactor(0.4);

        this.wheat = this.add.tileSprite
        (
            0,
            176 - 16,
            worldWidthX,
            16,
            'wheat'
        );
        this.wheat.setOrigin(0, 1);
        this.wheat.setScrollFactor(0.575);

        this.ground = this.add.tileSprite
        (
            -worldWidthX,
            this.sys.game.config.height,
            worldWidthX * 3,
            16,
            'ground'
        );

        this.ground.setOrigin(0, 1);
        this.physics.add.existing(this.ground);
        this.ground.body.setImmovable(true);
        this.ground.body.allowGravity = false;
        
        /*this.shed = this.add.image(75, this.sys.game.config.height - this.ground.height, 'shed');
        this.shed.setOrigin(0, 1);
        this.shed.setScrollFactor(0.65);

        this.fence = this.add.tileSprite
        (
          0,
          this.sys.game.config.height - this.ground.height,
          148,
          16,
          'fence'
        );
        this.fence.setScrollFactor(0.75);
        this.fence.setOrigin(0, 1);*/

        //this.couch = this.add.image(45, this.sys.game.config.height - this.ground.height, 'couch');
        //this.couch.setScrollFactor(0.8);
        //this.couch.setOrigin(0, 1);

        this.grill = this.add.image(15, this.sys.game.config.height - this.ground.height, 'pipe');
        this.grill.setScrollFactor(0.8);
        this.grill.setOrigin(0, 1);
     

        //END PROPS BEFORE PLAYER Level3Game


        //START PLAYER SETUP Level3Game


        createPlayer(this, 32, this.sys.game.config.height - 24);


        //END PLAYER SETUP Level3Game


        //START ENEMY SETUP Level3Game


        const cultPositions = 
        [
            { x: 500, y: 100 },
            { x: 1200, y: 100 }
        ];
        
        cultCreator(this, cultPositions);
        
        const cultKnifePositions = 
        [
            { x: 400, y: 100 },
            { x: 500, y: 100 },
            { x: 600, y: 100 },
            { x: 700, y: 100 },
            { x: 800, y: 100 },
            { x: 900, y: 100 },
            { x: 1000, y: 100 },
            { x: 1100, y: 100 },
            { x: 1200, y: 100 },
            { x: 1300, y: 100 }
        ];
        
        cultKnifeCreator(this, cultKnifePositions);
        
        const eyePositions = 
        [
            { x: 500, y: 100 },
            { x: 1200, y: 100 }
        ];
        
        eyeCreator(this, eyePositions);
        
        
        //END ENEMY SETUP Level3Game
        
        
        //START PROPS AFTER PLAYER Level3Game
        

        this.pipe = new pipeNext(this, 1400, this.sys.game.config.height - this.ground.height, 'Level4Game');

        this.grasstop = this.add.tileSprite
        (
                0,
                this.sys.game.config.height - this.ground.height,
                worldWidthX,
                16,
                'grasstop'
        );
        this.grasstop.setOrigin(0, 1);
        
        this.physics.add.collider(this.player, this.ground);
        
        makeRain(this, 'bloodrain');
        
        filterColors(this, 0xffcccc);
        
        
        //END PROPS AFTER PLAYER Level3Game


        //START CAMERA SETUP Level3Game


        this.cameras.main.setBounds(0, 0, worldWidthX, 176);
        this.cameras.main.startFollow(this.player, true, 1, 1, 0, (this.sys.game.config.height / 2));
        this.cameras.main.setZoom(1);


        //END CAMERA SETUP Level3Game
    }
    
    update(time, delta)
    {
      if(this.player.health < 1)
      {
        this.scene.stop('Level3Game');
        this.scene.start('Level2Game');
      }
      
      cultSeparation(this.cults, this.player);
      eyeSeparation(this.eyes, this.player);
    }
  }
  
  class Level4Game extends Phaser.Scene
  {
    constructor()
    {
      super({key: 'Level4Game'});
    }

    create()
    {
        //START BASIC SETUP Level4Game


        const worldWidthX = 2000;
        this.physics.world.setBounds(0, 0, worldWidthX, 176);
        this.cursors = this.input.keyboard.createCursorKeys();


        //END BASIC SETUP Level4Game


        //START PROPS BEFORE PLAYER Level4Game


        this.sky = this.add.tileSprite(0, 0, worldWidthX, this.sys.game.config.height, 'redsky').setOrigin(0, 0);
        this.sky.setScrollFactor(0.1);
        
        this.scarecrow = this.add.image(200, this.sys.game.config.height - 16, 'scarecrow').setOrigin(0, 1);
        this.scarecrow.setScrollFactor(0.4);

        this.wheat = this.add.tileSprite
        (
            0,
            176 - 16,
            worldWidthX,
            16,
            'wheat'
        );
        this.wheat.setOrigin(0, 1);
        this.wheat.setScrollFactor(0.575);

        this.ground = this.add.tileSprite
        (
                -worldWidthX,
                this.sys.game.config.height,
                worldWidthX * 3,
                16,
                'ground'
        );

        this.ground.setOrigin(0, 1);
        this.physics.add.existing(this.ground);
        this.ground.body.setImmovable(true);
        this.ground.body.allowGravity = false;
        
        //this.shed = this.add.image(75, this.sys.game.config.height - this.ground.height, 'shed');
        //this.shed.setOrigin(0, 1);
        //this.shed.setScrollFactor(0.65);

        /*this.fence = this.add.tileSprite
        (
          0,
          this.sys.game.config.height - this.ground.height,
          148,
          16,
          'fence'
        );
        this.fence.setScrollFactor(0.75);
        this.fence.setOrigin(0, 1);*/

        //this.couch = this.add.image(45, this.sys.game.config.height - this.ground.height, 'couch');
        //this.couch.setScrollFactor(0.8);
        //this.couch.setOrigin(0, 1);

        this.grill = this.add.image(15, this.sys.game.config.height - this.ground.height, 'pipe');
        this.grill.setScrollFactor(0.8);
        this.grill.setOrigin(0, 1);
     

        //END PROPS BEFORE PLAYER Level4Game


        //START PLAYER SETUP Level4Game


        createPlayer(this, 32, this.sys.game.config.height - 24);


        //END PLAYER SETUP Level4Game


        //START ENEMY SETUP Level4Game


        const cultPositions = 
        [
          { x: 600, y: 100 },
          { x: 600, y: 100 },
          { x: 600, y: 100 },
          { x: 600, y: 100 },
          { x: 600, y: 100 },
          { x: 600, y: 100 },
          { x: 900, y: 100 },
          { x: 1000, y: 100 },
          { x: 1500, y: 100 },
          { x: 1500, y: 100 },
          { x: 1500, y: 100 },
          { x: 1500, y: 100 },
          { x: 1500, y: 100 },
          { x: 1500, y: 100 }
        ];
        
        cultCreator(this, cultPositions);
        
        const cultKnifePositions = 
        [
            { x: -150, y: 100 },
            { x: 400, y: 100 },
            { x: 700, y: 100 },
            { x: 800, y: 100 },
            { x: 900, y: 100 }
        ];
        
        cultKnifeCreator(this, cultKnifePositions);
        
        const eyePositions = 
        [
            { x: 600, y: 100 },
            { x: 600, y: 100 },
            { x: 600, y: 100 },
            { x: 900, y: 100 },
            { x: 1500, y: 100 },
            { x: 1500, y: 100 },
            { x: 1500, y: 100 },
        ];
        
        eyeCreator(this, eyePositions);
        
        
        //END ENEMY SETUP Level4Game

     
        //START PROPS AFTER PLAYER Level4Game
        

        this.pipe = new pipeNext(this, 1950, this.sys.game.config.height - this.ground.height, 'MainMenu');

        this.grasstop = this.add.tileSprite
        (
                0,
                this.sys.game.config.height - this.ground.height,
                worldWidthX,
                16,
                'grasstop'
        );
        this.grasstop.setOrigin(0, 1);
        
        this.physics.add.collider(this.player, this.ground);
        
        filterColors(this, 0xff9999);
        
        
        //END PROPS AFTER PLAYER Level4Game


        //START CAMERA SETUP Level4Game


        this.cameras.main.setBounds(0, 0, worldWidthX, 176);
        this.cameras.main.startFollow(this.player, true, 1, 1, 0, (this.sys.game.config.height / 2));
        this.cameras.main.setZoom(1);


        //END CAMERA SETUP Level4Game
    }
    
    update(time, delta)
    {
      if(this.player.health < 1)
      {
        this.scene.stop('Level4Game');
        this.scene.start('Level3Game');
      }
      
      cultSeparation(this.cults, this.player);
      eyeSeparation(this.eyes, this.player);
    }
  }
  
  const config =
  {
    type: Phaser.AUTO,
    pixelArt: true,
    width: Math.max(385, Math.min(400, (window.innerWidth / window.innerHeight) * 176)),
    height: 176,

    scale:
    {
      mode: Phaser.Scale.FIT,
      autoCenter: Phaser.Scale.CENTER_BOTH
    },

    physics:
    {
      default: 'arcade',
      arcade:
      {
        gravity: { y: 300 },
        debug: false
      }
    },

    scene:
    [
      Loading,
      MainMenu,
      Level1Game,
      Level2Game,
      Level3Game,
      Level4Game
    ]
  };

  const game = new Phaser.Game(config);

</script>
</body>
</html>