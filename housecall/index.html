<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>House Call</title>
  <meta name="description" content="2d video game">
  <script src="//cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.js"></script>
  <link rel="shortcut icon" type="image" href="./assets/cultknifelogo.png">
  <style type="text/css">
    body {
      margin: 0;
      width: 100%;
      height: 100vh;
      height: 100dvh;
      background-color: black;
      overflow: hidden;
    }
  </style>
</head>
<body>

<script type="text/javascript">
  class playerBullet extends Phaser.Physics.Arcade.Sprite
  {
    constructor(scene, x, y, texture)
    {
      super(scene, x, y, texture);
      this.speed = 400;
      this.setActive(false);
      this.setVisible(false);
      this.scene = scene;
    }

    fire(x, y, angle, damage)
    {
        this.originX = x;
        this.body.reset(x, y);
        this.setActive(true);
        this.setVisible(true);
        this.setRotation(angle);
        this.damage = damage;
     
        this.scene.physics.velocityFromRotation(angle, this.speed, this.body.velocity);
       
        const isFollowingX = Math.abs(this.scene.cameras.main.midPoint.x - this.scene.player.x) < 1;
        if(isFollowingX)
        {
            this.body.velocity.x += this.scene.player.body.velocity.x;
        }
      
        this.body.allowGravity = false;
    }

    preUpdate(time, delta)
    {
      super.preUpdate(time, delta);

      if(this.y < 0 || this.y > this.scene.sys.game.config.height || this.x > this.originX + 200 || this.x < this.originX - 200)
      {
        this.setActive(false);
        this.setVisible(false);
        this.destroy();
      }
    }

    collided()
    {
      this.setActive(false);
      this.setVisible(false);
      this.destroy();
    }
  }

  class cultOrb extends Phaser.Physics.Arcade.Sprite
  {
    constructor(scene, x, y)
    {
      super(scene, x, y, 'cultorb');
      this.speed = 200;
      this.setActive(false);
      this.setVisible(false);
    }

    fire(x, y, angle)
    {
      this.body.reset(x, y);
      this.setActive(true);
      this.setVisible(true);
      this.setRotation(angle);
      this.scene.physics.velocityFromRotation(angle, this.speed, this.body.velocity);
      this.body.allowGravity = false;
      this.originX = x;
    }

    preUpdate(time, delta)
    {
      super.preUpdate(time, delta);

      if(this.y < 0 || this.y > this.scene.sys.game.config.height || this.x > this.originX + 1000 || this.x < this.originX - 1000)
      {
        this.setActive(false);
        this.setVisible(false);
        this.destroy();
      }
    }

    collided()
    {
      this.setActive(false);
      this.setVisible(false);
      this.destroy();
    }
  }

  class cult extends Phaser.Physics.Arcade.Sprite
  {
    constructor(scene, x, y, player, cultOrbHolder)
    {
        super(scene, x, y, 'cult');

        scene.add.existing(this);
        scene.physics.add.existing(this);
        this.setActive(true);
        this.setVisible(true);
        this.health = 15;
        this.initialHealth = this.health;
        this.setBounce(0);
        this.player = player;
        this.alert = false;
        this.orbs = cultOrbHolder;
        this.distancePref = 100;
        this.initalDistancePref = this.distancePref;
        this.distanceOffset = 5;
        this.flip = false;
        this.scene = scene;
      
        if(!scene.anims.get('orbThrow'))
        {
            scene.anims.create
            ({
              key: 'orbThrow',
              frames: scene.anims.generateFrameNumbers('cult', { start: 2, end: 0 }),
              frameRate: 6,
              repeat: 0
            });
        }
        
        if(!scene.anims.get('cultOrbHurt'))
        {
            scene.anims.create
            ({
                key: 'cultOrbHurt',
                frames: [
                     { key: 'cult', frame: 3 },
                     { key: 'cult', frame: 0 }
                 ],
                frameRate: 2,
                repeat: 0
            });
        }
        
        this.bloodEmitter = this.scene.add.particles
        (
            0, 0, 
            'blood',
            {
                angle: { min: 0, max: 360 },
                speed: { min: 100, max: 200 },
                gravityY: 500,
                lifespan: { min: 750, max: 750 },
                quantity: 100,
                scale: { start: 0.5, end: 0 },
                alpha: { start: 1, end: 0 },
                blendMode: 'NORMAL',
                frequency: -1
            }
        );
    }

    preUpdate(time, delta)
    {
      super.preUpdate(time, delta);

      if(this.health < 1)
      {
        this.scene.sound.play('hurt');
        this.kill();
      }
      else
      {
        this.checkInRange();

        if(this.alert === true || this.health < this.initialHealth)
        {
          if(this.player.x < this.x && Math.abs(this.player.x - this.x) >= this.distancePref + this.distanceOffset)
          {
            this.setVelocityX(-110);
          }
          else if(this.player.x > this.x && Math.abs(this.player.x - this.x) >= this.distancePref + this.distanceOffset)
          {
            this.setVelocityX(110);
          }
          else if(Math.abs(this.player.x - this.x) >= this.distancePref - this.distanceOffset && Math.abs(this.player.x - this.x) <= this.distancePref + this.distanceOffset)
          {
            this.setVelocityX(0);
          }
          else
          {
            if (this.player.x < this.x)
            {
              this.setVelocityX(110);
            }
            else
            {
              this.setVelocityX(-110);
            }
          }

          if(this.x > this.player.x)
          {
            this.flip = false;
            this.setFlipX(false);
          }
          else
          {
            this.flip = true;
            this.setFlipX(true);
          }
        }
        else
        {
            if(this.flip === true)
            {
                this.setFlipX(true);
            }
            else
            {
                this.setFlipX(false);
            }
        }
      }
    }

    checkInRange()
    {
        if(this.alert === false && Math.abs(this.player.x - this.x) <= 200)
        {
            this.alert = true;
        }
    }
    
    shoot()
    {
        const orb = this.orbs.get(this.x, this.y, 'cultorb');

        if(orb)
        {
            if(this.flip === false)
            {
              orb.fire(this.x - (this.width / 2), this.y, Phaser.Math.DegToRad(180));
            }
            else
            {
              orb.fire(this.x - (this.width / 2), this.y, Phaser.Math.DegToRad(0));
            }

            this.play('orbThrow', false);
        }
    }
    
    buddha()
    {
        this.health = Number.MAX_SAFE_INTEGER;
    }
    
    kill()
    {
        this.bloodEmitter.setQuantity(100);
        this.bloodEmitter.emitParticleAt(this.x, this.y);
        const gameManager = this.scene.gameManager;
        if(gameManager.doubleFireUpgrade)
        {
            if(this.scene.player && this.scene.player.active)
            {
                this.scene.player.activateDoubleFire();
            } 
        }
        //this.scene.sound.play('hurt');
        this.setActive(false);
        this.setVisible(false);
        this.destroy();
    }
  }

  class cultKnife extends Phaser.Physics.Arcade.Sprite
  {
    constructor(scene, x, y, player)
    {
        super(scene, x, y, 'cultknife');

        scene.add.existing(this);
        scene.physics.add.existing(this);
        this.setActive(true);
        this.setVisible(true);
        this.health = 5;
        this.setBounce(0);
        this.player = player;
        this.alert = false;
        this.flip = true;
        this.scene = scene;
      
        this.bloodEmitter = this.scene.add.particles
        (
            0, 0, 
            'blood',
            {
                angle: { min: 0, max: 360 }, 
                speed: { min: 100, max: 200 },
                gravityY: 500,
                lifespan: { min: 750, max: 750 },
                quantity: 75,
                scale: { start: 0.5, end: 0 },
                alpha: { start: 1, end: 0 },
                blendMode: 'NORMAL',
                frequency: -1
            }
        );
        
        if(!scene.anims.get('knifeidle'))
        {
          scene.anims.create
          ({
            key: 'knifeidle',
            frames: scene.anims.generateFrameNumbers('cultknife', { start: 0, end: 2 }),
            frameRate: 4,
            repeat: -1
          });
        }
        
        if(scene.anims.get('knifeidle'))
        {
            this.play('knifeidle');
        }
    }

    preUpdate(time, delta)
    {
      super.preUpdate(time, delta);

      if(this.health < 1)
      {
        this.scene.sound.play('hurt');
        this.kill();
      }
      else
      {
        this.checkInRange();

        if(this.alert === true || this.health < 5)
        {
          if(Math.abs(this.player.x - this.x) >= 0 - 5 && Math.abs(this.player.x - this.x) <= 0 + 5)
          {
            this.setVelocityX(0);
          }
          else
          {
            if(this.player.x < this.x)
            {
              this.setVelocityX(-150);
              this.flip = false;
              this.setFlipX(false);
            }
            else
            {
              this.setVelocityX(150);
              this.flip = true;
              this.setFlipX(true);
            }
          }
        }
        else
        {
            if(this.flip === true)
            {
              this.setFlipX(true);
            }
            else
            {
              this.setFlipX(false);
            }
        }
      }
    }

    checkInRange()
    {
      if(this.alert === false && Math.abs(this.player.x - this.x) <= 200)
      {
        this.alert = true;
      }
    }
    
    kill()
    {
        this.bloodEmitter.setQuantity(100);
        this.bloodEmitter.emitParticleAt(this.x, this.y);
        const gameManager = this.scene.gameManager;
        if(gameManager.doubleFireUpgrade)
        {
            if(this.scene.player && this.scene.player.active)
            {
                this.scene.player.activateDoubleFire();
            } 
        }
        this.setActive(false);
        this.setVisible(false);
        this.destroy();
    }
  }

  class player extends Phaser.Physics.Arcade.Sprite
  {
    constructor(scene, x, y, playerBulletsHolder)
    {
        super(scene, x, y, 'player');

        scene.add.existing(this);
        scene.physics.add.existing(this);
        this.setSize(6, 16);
        this.setActive(true);
        this.setVisible(true);
        this.flip = false;
        this.aimAngle = 0;
        this.fireRate = 750;
        this.baseFireRate = this.fireRate;
        this.doubleFire = false;
        this.doubleFireDuration = 1500;
        this.lastPlayerShot = 0;
        this.health = 10;
        this.setBounce(0);
        this.setCollideWorldBounds(true);
        this.scene = scene;
        this.lastPlayerBlock = 0;
        this.blockRate = 750;
        this.block = false;
        this.playerBulletsHolder = playerBulletsHolder;
        this.canShoot = true;
        this.damagePerShot = 1;
        this.baseDamage = 1;
        this.initialDamage = this.baseDamage;
        this.fireMode = 'buckshot';
        this.pistolMoveFireRate = 1500;
        this.lastPistolMove = 0;
        this.lastShellCycle = 0;

        this.wasd =
        {
          space: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE),
          w: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),
          s: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),
          a: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),
          d: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D),
          q: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q),
          e: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E),
          shift: scene.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SHIFT)
        };

        this.mouseRef = scene.input;
        this.bullets = playerBulletsHolder;

        if(!scene.anims.get('pump'))
        {
            scene.anims.create
            ({
                key: 'pump',
                frames: scene.anims.generateFrameNumbers('player', { start: 1, end: 0 }),
                frameRate: 6,
                repeat: 0
            });
        }
        
        if(!scene.anims.get('block'))
        {
            scene.anims.create
            ({
                key: 'block',
                frames: [
                            { key: 'player', frame: 2 },
                            { key: 'player', frame: 0 }
                        ],
                frameRate: 2,
                repeat: 0
            });
        }
        
        if(!scene.anims.get('pistolmove'))
        {
            scene.anims.create
            ({
                key: 'pistolmove',
                frames: [
                            { key: 'player', frame: 5 },
                            { key: 'player', frame: 3 },
                            { key: 'player', frame: 3 },
                            { key: 'player', frame: 4 },
                            { key: 'player', frame: 3 },
                            { key: 'player', frame: 5 },
                            { key: 'player', frame: 0 }
                        ],
                frameRate: 7,
                repeat: 0
            });
        }

        this.shellEmitter = this.scene.add.particles
        (
            0, 0, 
            'shell',
            {
                angle: 
                {
                    onEmit: () => 
                    {
                        if(this.flip === true)
                        {
                            return Phaser.Math.Between(-45, 45);
                        }
                        else
                        {
                            return  Phaser.Math.Between(135, 225);
                        }
                    }
                }, 
                speed: { min: 100, max: 200 },
                gravityY: 300,
                lifespan: { min: 1000, max: 1000 },
                quantity: 1,
                scale: { start: 1, end: 1 },
                alpha: { start: 1, end: 1 },
                blendMode: 'NORMAL',
                frequency: -1
            }
        );

        this.slugShellEmitter = this.scene.add.particles
        (
            0, 0, 
            'slugshell',
            {
                angle: 
                {
                    onEmit: () => 
                    {
                        if(this.flip === true)
                        {
                            return Phaser.Math.Between(-45, 45);
                        }
                        else
                        {
                            return  Phaser.Math.Between(135, 225);
                        }
                    }
                }, 
                speed: { min: 100, max: 200 },
                gravityY: 300,
                lifespan: { min: 1000, max: 1000 },
                quantity: 1,
                scale: { start: 1, end: 1 },
                alpha: { start: 1, end: 1 },
                blendMode: 'NORMAL',
                frequency: -1
            }
        );

        this.birdShotShellEmitter = this.scene.add.particles
        (
            0, 0, 
            'birdshotshell',
            {
                angle: 
                {
                    onEmit: () => 
                    {
                        if(this.flip === true)
                        {
                            return Phaser.Math.Between(-45, 45);
                        }
                        else
                        {
                            return  Phaser.Math.Between(135, 225);
                        }
                    }
                }, 
                speed: { min: 100, max: 200 },
                gravityY: 300,
                lifespan: { min: 1000, max: 1000 },
                quantity: 1,
                scale: { start: 1, end: 1 },
                alpha: { start: 1, end: 1 },
                blendMode: 'NORMAL',
                frequency: -1
            }
        );

        this.orbDestory = this.scene.add.particles
        (
            0, 0, 
            'bulletcult',
            {
                angle: 
                {
                    onEmit: () => 
                    {
                        if(this.flip === true)
                        {
                            return Phaser.Math.Between(135, 225);
                        }
                        else
                        {
                            return Phaser.Math.Between(-45, 45);
                        }
                    }
                }, 
                speed: { min: 200, max: 200 },
                gravityY: 0,
                lifespan: { min: 1000, max: 1000 },
                quantity: 4,
                scale: { start: 1, end: 1 },
                alpha: { start: 1, end: 0 },
                blendMode: 'NORMAL',
                frequency: -1
            }
        );

        this.pistolCasing = this.scene.add.particles
        (
            0, 0, 
            'pistolcasing',
            {
                angle: 
                {
                    onEmit: () => 
                    {
                        if(this.flip === true)
                        {
                            return Phaser.Math.Between(-20, -45);
                        }
                        else
                        {
                            return  Phaser.Math.Between(200, 225);
                        }
                    }
                }, 
                speed: { min: 100, max: 200 },
                gravityY: 300,
                lifespan: { min: 1000, max: 1000 },
                quantity: 1,
                scale: { start: 1, end: 1 },
                alpha: { start: 1, end: 1 },
                blendMode: 'NORMAL',
                frequency: -1
            }
        );

        this.fireModeConfig = 
        {
            'buckshot': 
            {
                normalPelletType: 'bullet',
                doublePelletType: 'bulletcult',
                sound: 'shotgunshot',
                shellEmitter: this.shellEmitter,
                pelletCount: 10,
                spread: 25,
                spreadIncrement: 2.5
            },
            'slug': 
            {
                normalPelletType: 'slug',
                doublePelletType: 'slugcult',
                sound: 'slug',
                shellEmitter: this.slugShellEmitter,
                pelletCount: 1,
                spread: 0,
                spreadIncrement: 0
            },
            'birdshot': 
            {
                normalPelletType: 'bullet',
                doublePelletType: 'bulletcult',
                sound: 'birdshot',
                shellEmitter: this.birdShotShellEmitter,
                pelletCount: 20,
                spread: 40,
                spreadIncrement: 2
            }
        };

        this.on(Phaser.GameObjects.Events.DESTROY, () => 
        {
            if(this.doubleFireTimer)
            {
                this.doubleFireTimer.remove();
            }
        });
        
        this.scene.anims.get('pump').frameRate = 6;
    }

    preUpdate(time, delta)
    {
        super.preUpdate(time, delta);

        if(this.health < 1)
        {
            this.setActive(false);
            this.setVisible(false);
            this.destroy();
        }
        else
        {
            this.checkBlock(time);
            this.checkMovement(); 
            this.checkFireMode(time);
            this.checkShooting(time);
            this.checkPistolMove(time);
            this.scene.input.activePointer.updateWorldPoint(this.scene.cameras.main);
            this.checkFlip(this.scene.input.activePointer);
            this.updateAimAngle(this.scene.input.activePointer);
        } 
    }
    
    checkPistolMove(time)
    {
        if((this.wasd.e.isDown || this.wasd.q.isDown) && time > this.lastPistolMove + this.pistolMoveFireRate)
        {
            this.play("pistolmove", true);
            
            this.playedPistolShootingSound = false;
            
            this.on(Phaser.Animations.Events.ANIMATION_UPDATE, (anim, frame) => 
            {
                if(frame.index === 4 && !this.playedPistolShootingSound) 
                {
                    this.playedPistolShootingSound = true;
                    this.scene.sound.play('pistolsound');
                    
                    const bullet = this.bullets.get(this.x, this.y, 'slug');

                    if(bullet)
                    {
                        let pistolDamage = 7;
                        
                        const gameManager = this.scene.gameManager;
                         
                        if(gameManager.pistolUpgrade)
                        {
                            pistolDamage = 14;
                        }
                        
                        if(this.flip === false)
                        {
                          bullet.fire(this.x + (this.width / 2) + (this.width / 16), this.y - (this.height / 32) - (this.height / 16), Phaser.Math.DegToRad(0), pistolDamage);
                        }
                        else
                        {
                          bullet.fire(this.x - (this.width / 2) - (this.width / 16), this.y - (this.height / 32) - (this.height / 16), Phaser.Math.DegToRad(180), pistolDamage);
                        }
                        
                        this.pistolCasing.emitParticleAt(this.x, this.y);
                    }  
                }
            });
            
            this.lastPistolMove = time;
        }
    }
    
    checkFireMode(time)
    {
        const gameManager = this.scene.gameManager;
                         
        if(gameManager.multiAmmoUpgrade)
        {
            if(time > this.lastShellCycle + 50)
            {
                let randomShell = Math.floor(Math.random() * (3 - 1 + 1)) + 1;
                
                switch(randomShell)
                {
                    case 1:
                        this.fireMode = 'buckshot';
                        break;
                        
                    case 2:
                        this.fireMode = 'slug';
                        break;
                        
                    case 3:
                        this.fireMode = 'birdshot';
                        break;
                }
                
                this.lastShellCycle = time;
            }
        }
            
        if(this.fireMode === 'buckshot')
        {
            this.damagePerShot = this.baseDamage;
        }
        else if(this.fireMode === 'slug')
        {
            this.damagePerShot = this.baseDamage * 5;
        }
        else if(this.fireMode === 'birdshot')
        {
            this.damagePerShot = this.baseDamage * 0.6;
        }
    }
    
    checkShooting(time)
    {
        if(this.mouseRef.activePointer.isDown && time > this.lastPlayerShot + this.fireRate && this.mouseRef.activePointer.leftButtonDown())
        {
          this.mouseRef.mouse.disableContextMenu();

            if(this.canShoot)
            {
                this.shoot(time);
                this.lastPlayerShot = time;
                this.play("pump", true);
            }
        }
    }
    
    shoot()
    {
        const fireConfig = this.fireModeConfig[this.fireMode];
        
        let offset = -(fireConfig.spread / 2);

        for (let i = 0; i < fireConfig.pelletCount; i++)
        {
            const pelletType = this.doubleFire ? fireConfig.doublePelletType : fireConfig.normalPelletType;
            
            const bullet = this.bullets.get(this.x, this.y, pelletType);

            if(bullet)
            {
                if(this.flip === false)
                {
                  bullet.fire(this.x + (this.width / 2) + (this.width / 16), this.y - (this.height / 32) - (this.height / 16), this.aimAngle + Phaser.Math.DegToRad(offset), this.damagePerShot);
                }
                else
                {
                  bullet.fire(this.x - (this.width / 2) - (this.width / 16), this.y - (this.height / 32) - (this.height / 16), this.aimAngle + Phaser.Math.DegToRad(offset), this.damagePerShot);
                }

                offset += fireConfig.spreadIncrement;
            }
        }
        
        this.scene.sound.play(fireConfig.sound);
        fireConfig.shellEmitter.emitParticleAt(this.x, this.y);
    }
    
    checkMovement()
    {
        if((this.wasd.a.isDown || this.scene.cursors.left.isDown))
        {
            this.setVelocityX(-120);
        }
        else if((this.wasd.d.isDown || this.scene.cursors.right.isDown))
        {
            this.setVelocityX(120);
        }
        else
        {
            this.setVelocityX(0);
        }

        if((this.wasd.space.isDown || this.wasd.w.isDown || this.scene.cursors.up.isDown) && this.body.touching.down)
        {
            this.setVelocityY(-120);
        }
    }
    
    defenceParticles()
    {
        if(this.flip === false)
        {
            this.orbDestory.emitParticleAt(this.x + 6, this.y);
        }
        else
        {
            this.orbDestory.emitParticleAt(this.x - 6, this.y);
        }
    }
    
    checkBlock(time)
    {
        if(this.wasd.shift.isDown && time > this.lastPlayerBlock + this.blockRate)
        {
            this.play("block", false);
            this.lastPlayerBlock = time;
        }
        else if(this.mouseRef.activePointer.isDown && time > this.lastPlayerBlock + this.blockRate && this.mouseRef.activePointer.rightButtonDown())
        {
            this.mouseRef.mouse.disableContextMenu();
            this.play("block", false);
            this.lastPlayerBlock = time;
        }
        
        let xOffset;
        
        if(this.anims.isPlaying && this.anims.currentAnim.key === 'block' && this.anims.currentFrame.index === 1)
        {
            this.block = true;
            this.setSize(8, 16);
            if(this.flip === false)
            {
                xOffset = 6;
            }
            else
            {
                xOffset = 3;
            }
            
            this.body.setOffset(xOffset, 0);
        }
        else
        {
            this.block = false;
            this.setSize(6, 16);
            if(this.flip === false)
            {
                xOffset = 3;
            }
            else
            {
                xOffset = 8;
            }
            this.body.setOffset(xOffset, 0);
        }
    }

    checkFlip(pointer)
    {
        if(pointer.worldX < this.getCenter().x)
        {
            this.setFlipX(true);
            this.flip = true;
        }
        else
        {
            this.setFlipX(false);
            this.flip = false;
        }
    }

    updateAimAngle(pointer)
    {
        if(this.flip === false)
        {
            this.aimAngle = Phaser.Math.Angle.Between
            (
                this.x + (this.width / 2) + (this.width / 16),
                this.y - (this.height / 32) - (this.height / 16),
                pointer.worldX,
                pointer.worldY
            );
        }
        else
        {
            this.aimAngle = Phaser.Math.Angle.Between
            (
                this.x - (this.width / 2) - (this.width / 16),
                this.y - (this.height / 32) - (this.height / 16),
                pointer.worldX,
                pointer.worldY
            );
        }
    }
    
    activateDoubleFire()
    {
        this.doubleFire = true;
        
        if(this.doubleFire === true)
        {
            this.fireRate = 325;
            this.scene.anims.get('pump').frameRate = 12;
        }
        
        if(this.doubleFireTimer)
        {
            this.doubleFireTimer.remove();
        }
        
        this.doubleFireTimer = this.scene.time.delayedCall(this.doubleFireDuration, () => 
        {
            this.doubleFire = false;
            this.fireRate = this.baseFireRate;
            this.scene.anims.get('pump').frameRate = 6;
        });
    }
    
    buddha()
    {
        this.health = Number.MAX_SAFE_INTEGER;
    }
  }

  class eye extends Phaser.Physics.Arcade.Sprite
  {
    constructor(scene, x, y, eyeOrbHolder)
    {
        super(scene, x, y, 'eye');

        scene.add.existing(this);
        scene.physics.add.existing(this);
        this.setActive(true);
        this.setVisible(true);
        this.setBounce(0);
        this.setCollideWorldBounds(true);
        this.body.setAllowGravity(false);
        this.body.allowGravity = false;
        this.health = 4;
        this.initialHealth = this.health;
        this.alert = false;
        this.scene = scene;
        this.player = this.scene.player;
        this.distancePref = 100;
        this.initalDistancePref = this.distancePref;
        this.distanceOffset = 5;
        this.orbs = eyeOrbHolder;

        this.explode = this.scene.add.particles
        (
            0, 0, 
            'eyechunk',
            {
                angle: { min: 0, max: 360 }, 
                speed: { min: 100, max: 200 },
                gravityY: 500,
                lifespan: { min: 750, max: 750 },
                quantity: 10,
                scale: { start: 0.5, end: 0 },
                alpha: { start: 1, end: 0 },
                blendMode: 'NORMAL',
                frequency: -1
            }
        );

        if(scene.ground)
        {
            scene.physics.add.collider(this, scene.ground);
        }
    }
    
    preUpdate(time, delta)
    {
        if(this.health < 1)
        {
            this.scene.sound.play('hurt');
            this.kill();
        }
        else
        {
            this.checkInRange();

            if(this.alert === true || this.health < this.initialHealth)
            {
              if(this.player.x < this.x && Math.abs(this.player.x - this.x) >= this.distancePref + this.distanceOffset)
              {
                this.setVelocityX(-110);
              }
              else if(this.player.x > this.x && Math.abs(this.player.x - this.x) >= this.distancePref + this.distanceOffset)
              {
                this.setVelocityX(110);
              }
              else if(Math.abs(this.player.x - this.x) >= this.distancePref - this.distanceOffset && Math.abs(this.player.x - this.x) <= this.distancePref + this.distanceOffset)
              {
                this.setVelocityX(0);
              }
              else
              {
                if (this.player.x < this.x)
                {
                  this.setVelocityX(110);
                }
                else
                {
                  this.setVelocityX(-110);
                }
              }

              if(this.x > this.player.x)
              {
                this.flip = false;
              }
              else
              {
                this.flip = true;
              }
            }
        }
    }
    
    shoot()
    {
        const orb = this.orbs.get(this.x, this.y, 'cultorb');

        if(orb)
        {
            orb.fire(this.x, this.y, Phaser.Math.Angle.Between(this.x, this.y, this.player.x, this.player.y));
        }
    }
    
    checkInRange()
    {
        if(this.alert === false && Math.abs(this.player.x - this.x) <= 200)
        {
            this.alert = true;
        }
    }
    
    kill()
    {
        this.explode.emitParticleAt(this.x, this.y);
        const gameManager = this.scene.gameManager;
        if(gameManager.doubleFireUpgrade && this.scene.player.active)
        {
            if(this.scene.player && this.scene.player.active)
            {
                this.scene.player.activateDoubleFire();
            } 
        }
        this.destroy();
    }
}

  class pipeNext extends Phaser.Physics.Arcade.Sprite
  {
      constructor(scene, x, y, key, fromLevel, gameManager) 
      {
        super(scene, x, y, 'pipe');
        
        this.pipe = scene.physics.add.sprite(x, y, 'pipe');
        this.pipe.setOrigin(0, 1);
        this.pipe.body.allowGravity = false;
        this.pipe.body.setImmovable(true);
        scene.physics.add.collider(this.pipe, this.ground);
        
        if(!scene.anims.get('stabAnim'))
        {
            scene.anims.create
            ({
                key: "stabAnim",
                frames: this.anims.generateFrameNumbers('stab', {start: 0, end: 2 }),
                frameRate: 2,
                repeat: 0
            });
        }
        scene.stab = scene.add.sprite(this.pipe.x + 1, this.pipe.y, "stab").setOrigin(0, 1);
        scene.stab.setActive(false);
        scene.stab.setVisible(false);
        
        scene.physics.add.collider(this.pipe, scene.player, (pipe, player) =>
        {
          player.destroy();
          scene.stab.setActive(true);
          scene.stab.setVisible(true);
          scene.sound.play('powerup');
          
          scene.stab.on(Phaser.Animations.Events.ANIMATION_UPDATE, (anim, frame) => 
            {
                if(frame.index === 2) 
                {
                    let aCultActive = false;
                    scene.sound.play('stab');
                    
                    if(scene.cults && scene.cults.children.entries)
                    {
                        const cultsArray = scene.cults.children.entries; 
                        
                        for(let i = cultsArray.length - 1; i >= 0; i--) 
                        {
                            const cult = cultsArray[i];
                            aCultActive = true;
                            cult.kill();  
                        }
                    }
                    
                    if(scene.cultKnifes && scene.cultKnifes.children.entries)
                    {
                        const cultKnifesArray = scene.cultKnifes.children.entries; 
                        
                        for(let i = cultKnifesArray.length - 1; i >= 0; i--) 
                        {
                            const cultKnife = cultKnifesArray[i];
                            aCultActive = true;
                            cultKnife.kill();  
                        }
                    }
                    
                    if(scene.eyes && scene.eyes.children.entries)
                    {
                        const eyesArray = scene.eyes.children.entries; 
                        
                        for(let i = eyesArray.length - 1; i >= 0; i--) 
                        {
                            const eye = eyesArray[i];
                            aCultActive = true;
                            eye.kill();  
                        }
                    }
                    
                    if(aCultActive)
                    {
                        scene.sound.play('hurt');
                    }
                }
            });
        
          scene.stab.play("stabAnim", true);
        });
        
        scene.stab.on(Phaser.Animations.Events.ANIMATION_COMPLETE, () => 
        {
            transitionLevels(scene, gameManager);
        });
      }
  }
  
  function transitionLevels(scene, gameManager)
  {
        if(gameManager.currentLevel === 1)
        {
            if(gameManager.visitedUpgradeRoom1 === true)
            {
                scene.scene.start('Level2Game');
                scene.scene.launch('HUD');
            }
            else
            {
                gameManager.visitedUpgradeRoom1 = true;
                scene.scene.start('UpgradeRoom');
                scene.scene.stop('HUD');
            }
        }
        else if(gameManager.currentLevel === 2)
        {
            if(gameManager.visitedUpgradeRoom2 === true)
            {
                scene.scene.start('Level3Game');
                scene.scene.launch('HUD');
            }
            else
            {
                gameManager.visitedUpgradeRoom2 = true;
                scene.scene.start('UpgradeRoom');
                scene.scene.stop('HUD');
            }
        }
        else if(gameManager.currentLevel === 3)
        {
            if(gameManager.visitedUpgradeRoom3 === true)
            {
                scene.scene.start('Level4Game');
                scene.scene.launch('HUD');
            }
            else
            {
                gameManager.visitedUpgradeRoom3 = true;
                scene.scene.start('UpgradeRoom');
                scene.scene.stop('HUD');
            }
        }
        else if(gameManager.currentLevel === 4)
        {
            scene.scene.start('MainMenu');
            scene.scene.stop('HUD');
        }
  }

  class Loading extends Phaser.Scene
  {
    constructor()
    {
      super({key: 'Loading'});
    }

    preload()
    {
        this.load.image('sky', 'assets/sky.png');
        this.load.spritesheet('player', 'assets/player.png', {frameWidth: 16, frameHeight: 16});
        this.load.image('ground', 'assets/grass.png');
        this.load.image('bullet', 'assets/bullet.png');
        this.load.image('barn', 'assets/barn.png');
        this.load.image('fence', 'assets/fence.png');
        this.load.image('stars', 'assets/stars.png');
        this.load.image('cross', 'assets/cross.png');
        this.load.spritesheet('cult', './assets/cult.png', {frameWidth: 16, frameHeight: 16});
        this.load.image('couch', './assets/couch.png');
        this.load.image('tractor', './assets/tractor.png');
        this.load.image('grasstop', './assets/grasstop.png');
        this.load.image('grill', './assets/grill.png');
        this.load.spritesheet('cultknife', './assets/cultknife.png', {frameWidth: 16, frameHeight: 16});
        this.load.image('copcar', './assets/copcar.png');
        this.load.image('cultorb', './assets/cultorb.png');
        this.load.image('wheat', './assets/wheat.png');
        this.load.image('shed', './assets/shed.png');
        this.load.image('silo', './assets/silo.png');
        this.load.image('scarecrow', './assets/scarecrow.png');
        this.load.image('pipe', './assets/pipe.png');
        this.load.image('eye', './assets/eye.png');
        this.load.spritesheet('stab', './assets/stab.png', {frameWidth: 12, frameHeight: 18});
        this.load.image('blood', 'assets/bloodparticle.png');
        this.load.image('eyechunk', 'assets/eyechunk.png');
        this.load.image('shell', 'assets/shell.png');
        this.load.image('raindrop', 'assets/raindrop.png');
        this.load.image('bloodrain', 'assets/bloodrain.png');
        this.load.image('redsky', 'assets/redsky.png');
        this.load.image('redskyrain', 'assets/redskyrain.png');
        this.load.image('bulletcult', 'assets/bulletcult.png');
        this.load.image('slug', 'assets/slug.png');
        this.load.image('slugcult', 'assets/slugcult.png');
        this.load.image('slugshell', 'assets/slugshell.png');
        this.load.image('slugicon', 'assets/slugicon.png');
        this.load.image('birdshotshell', 'assets/birdshotshell.png');
        this.load.image('birdshoticon', 'assets/birdshoticon.png');
        this.load.image('healthicon', 'assets/healthicon.png');
        this.load.image('shieldicon', 'assets/shieldicon.png');
        this.load.image('damageicon', 'assets/damageicon.png');
        this.load.image('cultenergyicon', 'assets/cultenergyicon.png');
        this.load.image('hollowpointsicon', 'assets/hollowpointsicon.png');
        this.load.image('pistolcasing', 'assets/pistolcasing.png');
        this.load.image('multiammoicon', 'assets/multiammoicon.png');

        this.load.audio('shotgunshot', 
        [
            'assets/shotgunshot.wav'
        ]);
        
        this.load.audio('slug', 
        [
            'assets/slug.wav'
        ]);
        
        this.load.audio('orbthrow', 
        [
            'assets/orbthrow.wav'
        ]);
        
        this.load.audio('hurt', 
        [
            'assets/hurt.wav'
        ]);
        
        this.load.audio('powerup', 
        [
            'assets/powerup.wav'
        ]);
        
        this.load.audio('block', 
        [
            'assets/block.wav'
        ]);
        
        this.load.audio('stab', 
        [
            'assets/stab.wav'
        ]);
        
        this.load.audio('eyeorb', 
        [
            'assets/eyeorb.wav'
        ]);
        
        this.load.audio('birdshot', 
        [
            'assets/birdshot.wav'
        ]);
        
        this.load.audio('switchfiremode', 
        [
            'assets/switchfiremode.wav'
        ]);
        
        this.load.audio('pistolsound', 
        [
            'assets/pistolsound.wav'
        ]);
    }

    create()
    {
      this.levelSelect = this.add.text((this.sys.game.config.width / 2), this.sys.game.config.height / 2, 'Loading', { fontSize: '16px', fill: '#fff' }).setOrigin(0.5);
    }

    update()
    {
        this.scene.stop('Loading');
        this.scene.start('GameManager');
        this.scene.start('MainMenu');
    }
  }

  class MainMenu extends Phaser.Scene
  {
    constructor()
    {
      super({key: 'MainMenu'});
    }

    preload()
    {

    }

    create ()
    {
        //START BASIC SETUP MainMenu


        this.input.setDefaultCursor('');
        const worldWidthX = this.sys.game.config.width * 3;
        this.physics.world.setBounds(0, 0, worldWidthX / 3, 176);
        this.cursors = this.input.keyboard.createCursorKeys();
        this.gameManager = this.scene.get('GameManager');
        this.gameManager.reset();


        //END BASIC SETUP MainMenu


        //START PROPS BEFORE PLAYER MainMenu
        

        this.sky = this.add.tileSprite(0, 0, worldWidthX, this.sys.game.config.height, 'sky').setOrigin(0, 0);
        this.sky.setScrollFactor(0.1);

        this.stars = this.add.tileSprite(0, 0, worldWidthX, this.sys.game.config.height, 'stars').setOrigin(0, 0);
        this.stars.setScrollFactor(0.1);
        
        this.ground = this.add.tileSprite
        (
          0,
          this.sys.game.config.height,
          worldWidthX * 2,
          16,
          'ground'
        );

        this.ground.setOrigin(0, 1);
        this.physics.add.existing(this.ground);
        this.ground.body.setImmovable(true);
        this.ground.body.allowGravity = false;
        
        this.barn = this.add.image
        (
          (worldWidthX / 3) / 30,
          this.sys.game.config.height - this.ground.height,
          'barn'
        ).setOrigin(0, 1);
        this.barn.setTint(0x999999);
        this.barn.setScrollFactor(0.25);
        
        this.silo = this.add.image
        (
          this.barn.width + (worldWidthX / 3) / 30,
          this.sys.game.config.height - this.ground.height,
          'silo'
        );
        this.silo.setOrigin(0, 1);
        this.silo.setScrollFactor(0.225);
        
        this.cross = this.add.image
        (
          (worldWidthX / 3) + ((worldWidthX / 3) / 30),
          this.sys.game.config.height - this.ground.height,
          'cross'
        );
        this.cross.setOrigin(0, 1);
        this.cross.setScrollFactor(0.25);
        this.cross.setTint(0x999999);

        this.fence = this.add.tileSprite
        (
                this.sys.game.config.width / 2,
                this.sys.game.config.height - this.ground.height,
                worldWidthX,
                16,
                'fence'
        );
        this.fence.setScrollFactor(0.75);
        this.fence.setOrigin(0.25, 1);


        //END PROPS BEFORE PLAYER MainMenu
      
      
        //START PLAYER SETUP MainMenu


        createPlayer(this, Math.min(94, this.sys.game.config.width / 2), this.sys.game.config.height - 24, this.gameManager);
        this.player.buddha();


        //END PLAYER SETUP MainMenu
      
      
        //START ENEMY SETUP MainMenu
        
      
        const cultPositions = 
        [
            { x: worldWidthX / 2, y: 100 }
        ];
        
        cultCreator(this, cultPositions, this.gameManager);
        
        this.cults.children.entries.forEach(cult => 
        {
            cult.buddha();
        });
        
        
        //END ENEMY SETUP MainMenu
      
        
        //START PROPS AFTER PLAYER MainMenu
        
        
        this.copcar = this.add.image
        (
          worldWidthX / 4 + this.sys.game.config.width / 4 - this.sys.game.config.width / 8,
          this.sys.game.config.height - this.ground.height,
          'copcar'
        ).setOrigin(1, 1);
        
        this.pipe = this.physics.add.sprite(worldWidthX / 2 + this.sys.game.config.width / 4 - 8, this.sys.game.config.height - this.ground.height, 'pipe');
        this.pipe.setOrigin(0, 1);
        this.pipe.body.allowGravity = false;
        this.pipe.body.setImmovable(true);
        this.physics.add.collider(this.pipe, this.ground);
        
        if(!this.anims.get('stabAnim'))
        {
            this.anims.create
            ({
                key: "stabAnim",
                frames: this.anims.generateFrameNumbers('stab', {start: 0, end: 2 }),
                frameRate: 2,
                repeat: 0
            });
        }
        this.stab = this.add.sprite(this.pipe.x + 1, this.pipe.y, "stab").setOrigin(0, 1);
        this.stab.setActive(false);
        this.stab.setVisible(false);
        
        this.physics.add.collider(this.pipe, this.player, (pipe, player) =>
        {
          player.destroy();
          this.stab.setActive(true);
          this.stab.setVisible(true);
          this.sound.play('powerup');
          
          this.stab.on(Phaser.Animations.Events.ANIMATION_UPDATE, (anim, frame) => 
            {
                if(frame.index === 2) 
                {
                    this.sound.play('stab');
                    
                    this.cults.children.entries.forEach(cult => 
                    {
                        cult.health = -100;
                    });
                    
                    this.controls.destroy();
                    this.strafeControls.destroy();
                    this.jumpControls.destroy();
                    this.leftClickControls.destroy();
                    this.rightClickControls.destroy();
                    this.pistolControls.destroy();
                }
            });
        
            this.stab.play("stabAnim", true);
        });
        
        this.stab.on(Phaser.Animations.Events.ANIMATION_COMPLETE, () => 
        {
          this.cameras.main.pan(worldWidthX, this.sys.game.config.height / 2, 2000, 'Sine.easeInOut');
        });
        
        this.grasstop = this.add.tileSprite
        (
          0,
          this.sys.game.config.height - this.ground.height,
          worldWidthX,
          16,
          'grasstop'
        );
        this.grasstop.setOrigin(0, 1);
     
        this.logo = createText(this, worldWidthX / 6, this.sys.game.config.height / 2, 'House Call', 16, '#fff').setOrigin(0.5, 0.5);
        this.logo.setInteractive({cursor: 'pointer'});
      
        this.physics.add.existing(this.logo, true);
        this.physics.add.collider(this.logo, this.playerBulletsHolder, (logo, bullet) =>
        {
          bullet.destroy();
          logo.destroy();
          this.cameras.main.pan(worldWidthX / 2, this.sys.game.config.height / 2, 2000, 'Sine.easeInOut');
          
            this.time.delayedCall(2000, () =>
            {
                this.player.x = worldWidthX / 3 - this.player.width / 2;
                this.tweens.add
                ({
                    targets: this.player, 
                    x: worldWidthX / 3 + this.player.width / 2,               
                    y: this.sys.game.config.height - 24,               
                    duration: 250,       
                    ease: 'linear',       
                    onComplete: () => 
                    {
                        this.physics.world.setBounds(this.sys.game.config.width, 0, this.sys.game.config.width, 176);
                    }
                });
            }, [], this);
            
        });
        
        this.controls = createText(this, worldWidthX / 2, 10, 'Controls:', 16, '#fff');
        
        this.strafeControls = createText(this, worldWidthX / 2, 0 + this.controls.height + 20, 'A/D: Walk', 12, '#fff');
        this.jumpControls = createText(this, worldWidthX / 2, 0 + this.controls.height + this.strafeControls.height + 25, 'Space: Jump', 12, '#fff');
        this.rightClickControls = createText(this, worldWidthX / 2, 0 + this.controls.height + this.strafeControls.height + this.jumpControls.height + 30, 'Right-Click: Block', 12, '#fff');
        this.leftClickControls = createText(this, worldWidthX / 2, 0 + this.controls.height + this.strafeControls.height + this.jumpControls.height + this.rightClickControls.height + 35, 'Left-Click: Use Shotgun (Hold)', 12, '#fff');
        this.pistolControls = createText(this, worldWidthX / 2, 0 + this.controls.height + this.strafeControls.height + this.jumpControls.height + this.rightClickControls.height + this.leftClickControls.height + 40, 'Q/E: Use Pistol', 12, '#fff');
        
        this.start = createText(this, worldWidthX - this.sys.game.config.width / 2, this.sys.game.config.height / 2, 'Start', 16, '#fff').setOrigin(0.5, 0.5);
        this.start.setInteractive({cursor: 'pointer'});
        this.start.on('pointerdown', () =>
        {
          this.scene.stop('MainMenu');
          event.stopPropagation();
          this.scene.start('Level1Game');
        });
        
        
        //END PROPS AFTER PLAYER MainMenu
        
        
        //START CAMERA SETUP MainMenu
        
        
        this.cameras.main.setBounds(0, 0, worldWidthX, 176);
        this.cameras.scrollX = 0;
        this.cameras.scrollY = 0;
        //this.cameras.main.startFollow(this.player, true, 1, 1, 0, (this.sys.game.config.height / 2));
        this.cameras.main.setZoom(1);
        
        
        //END CAMERA SETUP MainMenu
    }

    update(time)
    {
        if(this.player.health < 1000)
        {
            this.player.buddha();
        }
    }
    
    
  }
  
    function createText(scene, x, y, words, size, color)
    {
        let newText = scene.add.text(x, y, words, { fontSize: size, fill: color}).setOrigin(0.5, 0);
        return newText;
    }
  
  function createLevelProps(scene)
  {
    scene.shed = scene.add.image(75, scene.sys.game.config.height - scene.ground.height, 'shed');
    scene.shed.setOrigin(0, 1);
    scene.shed.setScrollFactor(0.65);

    scene.fence = scene.add.tileSprite
    (
      0,
      scene.sys.game.config.height - scene.ground.height,
      148,
      16,
      'fence'
    );
    scene.fence.setScrollFactor(0.75);
    scene.fence.setOrigin(0, 1);

    scene.couch = scene.add.image(45, scene.sys.game.config.height - scene.ground.height, 'couch');
    scene.couch.setScrollFactor(0.8);
    scene.couch.setOrigin(0, 1);

    scene.grill = scene.add.image(15, scene.sys.game.config.height - scene.ground.height, 'grill');
    scene.grill.setScrollFactor(0.8);
    scene.grill.setOrigin(0, 1);
  }
  
  function createPlayer(scene, x, y, gameManager)
  {
        scene.playerBulletsHolder = scene.physics.add.group
        ({
          classType: playerBullet,
          maxSize: 60,
          runChildUpdate: true
        });

        scene.player = new player(scene, x, scene.sys.game.config.height - 24, scene.playerBulletsHolder);
        
        scene.player.canShoot = false;
        scene.time.delayedCall(200, () => scene.player.canShoot = true);
        
        if(scene.ground)
        {
            scene.physics.add.collider(scene.player, scene.ground);
        }
        
        scene.player.fireMode = gameManager.fireModeUpgrade;
        
        if(gameManager.damageUpgrade)
        {
            scene.player.baseDamage = 1.25;
        }
        
        if(gameManager.healthUpgrade)
        {
            scene.player.health = 20;
        }
        
        if(gameManager.alwaysBuddha)
        {
            scene.player.buddha();
        }
  }

  function cultSeparation(cults, player)
  {
    let cultsWithDistancesRight = [];
    let cultsWithDistancesLeft = [];

    cults.children.entries.forEach(cult =>
    {
      let distance = Phaser.Math.Distance.Between(player.x, player.y, cult.x, cult.y);

      if(player.x < cult.x)
      {
        cultsWithDistancesRight.push
        ({
            cult: cult,
            distance: distance
        });
      }
      else
      {
        cultsWithDistancesLeft.push
        ({
            cult: cult,
            distance: distance
        });
      }
    });

    cultsWithDistancesRight.sort((a, b) =>
    {
      return a.distance - b.distance;
    });

    cultsWithDistancesLeft.sort((a, b) =>
    {
      return a.distance - b.distance;
    });

    let newDistanceAdderRight = 0;
    cultsWithDistancesRight.forEach(item =>
    {
      item.cult.distancePref = item.cult.initalDistancePref + newDistanceAdderRight;
      newDistanceAdderRight += 16;
    });

    let newDistanceAdderLeft = 0;
    cultsWithDistancesLeft.forEach(item =>
    {
      item.cult.distancePref = item.cult.initalDistancePref + newDistanceAdderLeft;
      newDistanceAdderLeft += 16;
    });
  }
  
  function cultSynchro(scene, cults)
  {
        let aCultAcvite = false;
        
        cults.children.entries.forEach(cult => 
        {
            if(cult.alert && cult.visible) 
            {
                cult.shoot();
                
                if(!aCultAcvite)
                {
                    aCultAcvite = !aCultAcvite;
                }
            }
        });
        
        if(aCultAcvite)
        {
            scene.sound.play('orbthrow');
        }
  }
  
  function cultCreator(scene, cultPositions, gameManager)
  {
        scene.cultOrbHolder = scene.physics.add.group
        ({
          classType: cultOrb,
          maxSize: 30,
          runChildUpdate: true
        });
        scene.physics.add.overlap(scene.player, scene.cultOrbHolder, (player, orb) =>
        {
            if(!player.block)
            {
                player.health -= 10;
            }
            else
            {
                scene.sound.play('block');
                player.defenceParticles();
                player.activateDoubleFire();
                if(gameManager.blockUpgrade)
                {
                    player.play("block", false);
                }
            }
            orb.destroy();
        });
        
        scene.cults = scene.physics.add.group();
        
        let cultId = 0;
        cultPositions.forEach(pos => 
        {
            cultId += 1;
            const cultInstance = new cult(scene, pos.x, pos.y, scene.player, scene.cultOrbHolder);
            cultInstance.id = cultId;
            scene.cults.add(cultInstance);
        });
        
        if(scene.ground)
        {
            scene.physics.add.collider(scene.cults, scene.ground);
        }
        scene.physics.add.collider(scene.cults, scene.cults);
        scene.physics.add.overlap(scene.cults, scene.playerBulletsHolder, (cult, bullet) =>
        {
          cult.health -= bullet.damage;
          bullet.destroy();
          if(!cult.anims.isPlaying)
          {
            cult.play("cultOrbHurt", false);
          }
          cult.bloodEmitter.setQuantity(4);
          cult.bloodEmitter.emitParticleAt(cult.x, cult.y);
        });
        
        scene.time.addEvent
        ({
            delay: 1500,
            callback: () => cultSynchro(scene, scene.cults),
            callbackScope: this,
            loop: true
        });
  }
  
  function cultKnifeCreator(scene, cultKnifePositions, gameManager)
  {     
        scene.cultKnifes = scene.physics.add.group();
      
        cultKnifePositions.forEach(pos => 
        {
            const cultKnifeInstance = new cultKnife(scene, pos.x, pos.y, scene.player);
            scene.cultKnifes.add(cultKnifeInstance);
        });
        
        if(scene.ground)
        {
            scene.physics.add.collider(scene.cultKnifes, scene.ground);
        }
        
        scene.physics.add.overlap(scene.cultKnifes, scene.playerBulletsHolder, (cult, bullet) =>
        {
          cult.health -= bullet.damage;
          bullet.destroy();
          cult.bloodEmitter.setQuantity(4);
          cult.bloodEmitter.emitParticleAt(cult.x, cult.y);
        });
        
        scene.physics.add.collider(scene.player, scene.cultKnifes, (player, cult) =>
        {
          player.health -= 10;
        });
        
        scene.physics.add.collider(scene.cultKnifes, scene.cultKnifes);
  }
  
  function eyeCreator(scene, eyePositions, gameManager)
  {
        scene.eyeOrbHolder = scene.physics.add.group
        ({
          classType: cultOrb,
          maxSize: 30,
          runChildUpdate: true
        });
        scene.physics.add.overlap(scene.player, scene.eyeOrbHolder, (player, orb) =>
        {
          if(!player.block)
          {
              player.health -= 10;
          }
          else
          {
              scene.sound.play('block');
              player.defenceParticles();
              player.activateDoubleFire();
              if(gameManager.blockUpgrade)
                {
                    player.play("block", false);
                }
          }
          orb.destroy();
        });
        
        scene.eyes = scene.physics.add.group
        ({
            immovable: true,
            allowGravity: false
        });
        
        let eyeId = 0;
        eyePositions.forEach(pos =>
        {
            eyeId += 1;
            const eyeInstance = new eye(scene, pos.x, pos.y, scene.eyeOrbHolder);
            eyeInstance.id = eyeId;
            scene.eyes.add(eyeInstance);
        });

        if(scene.ground)
        {
            scene.physics.add.collider(scene.cultKnifes, scene.ground);
        }
        
        scene.physics.add.overlap(scene.eyes, scene.playerBulletsHolder, (eye, bullet) =>
        {
          eye.health -= bullet.damage;
          bullet.destroy();
        });
        
        scene.time.addEvent
        ({
            delay: 1500,
            callback: () => eyeSynchro(scene, scene.eyes),
            callbackScope: this,
            loop: true
        });
  }
  
  function eyeSeparation(eyes, player)
  {
    let eyesWithDistancesRight = [];
    let eyesWithDistancesLeft = [];

    eyes.children.entries.forEach(eye =>
    {
      let distance = Phaser.Math.Distance.Between(player.x, player.y, eye.x, eye.y);

      if(player.x < eye.x)
      {
        eyesWithDistancesRight.push
        ({
            eye: eye,
            distance: distance
        });
      }
      else
      {
        eyesWithDistancesLeft.push
        ({
            eye: eye,
            distance: distance
        });
      }
    });

    eyesWithDistancesRight.sort((a, b) =>
    {
      return a.distance - b.distance;
    });

    eyesWithDistancesLeft.sort((a, b) =>
    {
      return a.distance - b.distance;
    });

    let newDistanceAdderRight = 0;
    eyesWithDistancesRight.forEach(item =>
    {
      item.eye.distancePref = item.eye.initalDistancePref + newDistanceAdderRight;
      newDistanceAdderRight += 32;
    });

    let newDistanceAdderLeft = 0;
    eyesWithDistancesLeft.forEach(item =>
    {
      item.eye.distancePref = item.eye.initalDistancePref + newDistanceAdderLeft;
      newDistanceAdderLeft += 32;
    });
  }
  
  function eyeSynchro(scene, eyes)
  {
        let anEyeAcvite = false;
        
        eyes.children.entries.forEach(eye => 
        {
            if(eye.alert && (eye.visible))
            {
                eye.shoot();
                
                if(!anEyeAcvite)
                {
                    anEyeAcvite = !anEyeAcvite;
                }
            }
        });
        
        if(anEyeAcvite)
        {
            scene.sound.play('eyeorb');
        }
  }
  
  function makeRain(scene, texture)
  {
        scene.rain = scene.add.particles
        (
            0, 0, 
            texture,
            {
                x: { min: 0, max: scene.sys.game.config.width + (scene.sys.game.config.width / 5) },
                y: { min: -15, max:-7 },
                angle: { min: 90, max: 180 }, 
                speed: { min: 100, max: 300 },
                gravityY: 100,
                lifespan: { min: 1500, max: 1500 },
                quantity: 15,
                scale: { start: 0.35, end: 0.25 },
                alpha: { start: 1, end: 0 },
                blendMode: 'NORMAL',
                frequency: 50
            }
        );

        scene.rain.start();
        scene.rain.setScrollFactor(0);
  }
  
  function filterColors(scene, color)
  {
        if(scene.shed)
        {
            scene.shed.setTint(color);
        }
        if(scene.fence)
        {
            scene.fence.setTint(color);
        }
        if(scene.couch)
        {
            scene.couch.setTint(color);
        }
        if(scene.grill)
        {
            scene.grill.setTint(color);
        }
        if(scene.ground)
        {
            scene.ground.setTint(color);
        }
        if(scene.grasstop)
        {
            scene.grasstop.setTint(color);
        }
        if(scene.wheat)
        {
            scene.wheat.setTint(color);
        }
  }
  
    function createRandomEnemies(scene, spawnList, worldWidthX, gameManager)
    {
        function getRandomCoords(worldWidthX) 
        {
            let min = 600;
            return Math.floor(Math.random() * (worldWidthX - min + 1)) + min;
        }
        
        function positionTaken(xCoord, chosenPositions, range)
        {
            for(const position of chosenPositions) 
            {
                if(Math.abs(position - xCoord) <= range) 
                {
                    return true;
                }
            }
            
            return false;
        }
        
        const enemyData = new Map();
        
        for (const enemy of spawnList) 
        {
            const currentEnemy = enemy.type;
            const enemyAmount = enemy.amount;
            
            let positions = new Array();
            
            if(currentEnemy === 'cult')
            {
                const chosenPositions = new Set();
                
                for(let i = 0; i < enemyAmount; i++)
                {
                    let range = 8;
                    let xCoord;
                    
                    do
                    {
                        xCoord = getRandomCoords(worldWidthX);
                    }
                    while(positionTaken(xCoord, chosenPositions, range));
                     
                    const newCult = { x: xCoord, y: 100 };
                    chosenPositions.add(xCoord);
                    positions.push(newCult);
                }
                
                enemyData.set('cult', { positions: positions });
                cultCreator(scene, positions, gameManager);
            }    
            else if(currentEnemy === 'cultKnife')
            {
                const chosenPositions = new Set();
                
                for(let i = 0; i < enemyAmount; i++)
                {
                    let range = 8;
                    let xCoord;
                    
                    do
                    {
                        xCoord = getRandomCoords(worldWidthX);
                    }
                    while(positionTaken(xCoord, chosenPositions, range));
                     
                    const newCultKnife = { x: xCoord, y: 100 };
                    chosenPositions.add(xCoord);
                    positions.push(newCultKnife);
                }
                
                enemyData.set('cultKnife', { positions: positions });
                cultKnifeCreator(scene, positions, gameManager);
            }
            else if(currentEnemy === 'eye')
            {
                const chosenPositions = new Set();
                
                for(let i = 0; i < enemyAmount; i++)
                {
                    let range = 16;
                    let xCoord;
                    
                    do
                    {
                        xCoord = getRandomCoords(worldWidthX);
                    }
                    while(positionTaken(xCoord, chosenPositions, range));
                     
                    const newEye = { x: xCoord, y: 100 };
                    chosenPositions.add(xCoord);
                    positions.push(newEye);
                }
                
                enemyData.set('eye', { positions: positions });
                eyeCreator(scene, positions, gameManager);
            }
        }
        
        return enemyData;
    }
    
    function getRandomXAnywhere(worldWidthX)
    {
        return (Math.floor(Math.random() * (worldWidthX - 0 + 1)) + 0);
    }
    
    function getRandMinMax(min, max)
    {
        return (Math.floor(Math.random() * (max - min + 1)) + min);
    }
    
  class Level1Game extends Phaser.Scene
  {
    constructor()
    {
      super({ key: 'Level1Game' });
    }

    preload()
    {

    }

    create()
    {
        //START BASIC SETUP Level1Game

        
        this.input.setDefaultCursor('');
        const worldWidthX = 1800;
        this.physics.world.setBounds(0, 0, worldWidthX, 176);
        this.cursors = this.input.keyboard.createCursorKeys();
        this.gameManager = this.scene.get('GameManager');
        this.gameManager.updateHighestLevel(1);
        this.gameManager.updateCurrentLevel(1);
         

        //END BASIC SETUP Level1Game


        //START PROPS BEFORE PLAYER Level1Game
        

        this.sky = this.add.tileSprite(0, 0, worldWidthX, this.sys.game.config.height, 'sky').setOrigin(0, 0);
        this.sky.setScrollFactor(0.1);

        this.stars = this.add.tileSprite(0, 0, worldWidthX, this.sys.game.config.height, 'stars').setOrigin(0, 0);
        this.stars.setScrollFactor(0.1);
        
        if(!this.gameManager.scarecrowPos1)
        {
            let scarePos = getRandomXAnywhere(worldWidthX);
            this.scarecrow = this.add.image(scarePos, this.sys.game.config.height - 16, 'scarecrow').setOrigin(0, 1);
            this.gameManager.scarecrowPos1 = scarePos;
        }
        else
        {
            this.scarecrow = this.add.image(this.gameManager.scarecrowPos1, this.sys.game.config.height - 16, 'scarecrow').setOrigin(0, 1);
        }
        
        this.scarecrow.setScrollFactor(0.4);
        
        this.wheat = this.add.tileSprite
        (
            0,
            176 - 16,
            worldWidthX,
            16,
            'wheat'
        );
        this.wheat.setOrigin(0, 1);
        this.wheat.setScrollFactor(0.575);

        this.ground = this.add.tileSprite
        (
          0,
          this.sys.game.config.height,
          worldWidthX * 2,
          16,
          'ground'
        );

        this.ground.setOrigin(0, 1);
        this.physics.add.existing(this.ground);
        this.ground.body.setImmovable(true);
        this.ground.body.allowGravity = false;

        createLevelProps(this);


        //END PROPS BEFORE PLAYER Level1Game
      
      
        //START PLAYER SETUP Level1Game

        
        createPlayer(this, 32, this.sys.game.config.height - 24, this.gameManager);
        //this.player.buddha();


        //END PLAYER SETUP Level1Game
      
      
        //START ENEMY SETUP Level1Game
        
        
        if(this.gameManager.level1Data === null)
        {
            this.spawnList = 
            [
                { type: 'cult', amount: getRandMinMax(2, 3) },
                { type: 'cultKnife', amount: getRandMinMax(4, 5) }
            ];

            this.gameManager.level1Data = createRandomEnemies(this, this.spawnList, worldWidthX, this.gameManager);
        }
        else
        {
            for(const enemy of this.gameManager.level1Data.keys()) 
            {
                if(enemy === 'cult')
                {
                    let enemyData = this.gameManager.level1Data.get(enemy);
                    let enemyPositionArray = enemyData.positions;
                    cultCreator(this, enemyPositionArray, this.gameManager);
                }
                else if(enemy === 'cultKnife')
                {
                    let enemyData = this.gameManager.level1Data.get(enemy);
                    let enemyPositionArray = enemyData.positions;
                    cultKnifeCreator(this, enemyPositionArray, this.gameManager);
                }
            }
        }
        
        
        //END ENEMY SETUP Level1Game
      
        
        //START PROPS AFTER PLAYER Level1Game
        
        
        const thisLevel = 1;
        this.pipe = new pipeNext(this, 1600, this.sys.game.config.height - this.ground.height, 'Level2Game', thisLevel, this.gameManager);

        this.grasstop = this.add.tileSprite
        (
          0,
          this.sys.game.config.height - this.ground.height,
          worldWidthX,
          16,
          'grasstop'
        );
        this.grasstop.setOrigin(0, 1);
        
        this.tractor = this.physics.add.sprite(200, this.sys.game.config.height - this.ground.height, 'tractor');
        this.tractor.setOrigin(0, 1);
        this.tractor.body.allowGravity = false;
        this.tractor.body.setImmovable(true);

        this.physics.add.collider(this.tractor, this.ground);
        this.physics.add.collider(this.tractor, this.player);
        
        
        //END PROPS AFTER PLAYER Level1Game
        
        
        //START CAMERA SETUP Level1Game
        
        
        this.cameras.main.setBounds(0, 0, worldWidthX, 176);
        this.cameras.main.startFollow(this.player, true, 1, 1, 0, (this.sys.game.config.height / 2));
        this.cameras.main.setZoom(1);
        this.cameras.scrollX = 0;
        this.cameras.scrollY = 0;
        
        
        //END CAMERA SETUP Level1Game
    }

    update(time, delta)
    {
      if(this.player.health < 1)
      {
        this.scene.stop('Level1Game');
        this.scene.start('Level1Game');
      }
      
      cultSeparation(this.cults, this.player);
      //eyeSeparation(this.eyes, this.player);
    }
  }

  class Level2Game extends Phaser.Scene
  {
    constructor()
    {
      super({ key: 'Level2Game' });
    }

    preload()
    {

    }

    create()
    {
        //START BASIC SETUP Level2Game

        
        this.input.setDefaultCursor('');
        const worldWidthX = 2250;
        this.physics.world.setBounds(0, 0, worldWidthX, 176);
        this.cursors = this.input.keyboard.createCursorKeys();
        this.gameManager = this.scene.get('GameManager');
        this.gameManager.updateHighestLevel(2);
        this.gameManager.updateCurrentLevel(2);


        //END BASIC SETUP Level2Game


        //START PROPS BEFORE PLAYER Level2Game


        this.sky = this.add.tileSprite(0, 0, worldWidthX, this.sys.game.config.height, 'sky').setOrigin(0, 0);
        this.sky.setScrollFactor(0.1);
        this.sky.postFX.addColorMatrix().grayscale(1);
        
        if(!this.gameManager.scarecrowPos2)
        {
            let scarePos = getRandomXAnywhere(worldWidthX);
            this.scarecrow = this.add.image(scarePos, this.sys.game.config.height - 16, 'scarecrow').setOrigin(0, 1);
            this.gameManager.scarecrowPos2 = scarePos;
        }
        else
        {
            this.scarecrow = this.add.image(this.gameManager.scarecrowPos2, this.sys.game.config.height - 16, 'scarecrow').setOrigin(0, 1);
        }
        
        this.scarecrow.setScrollFactor(0.4);
        
        this.wheat = this.add.tileSprite
        (
            0,
            176 - 16,
            worldWidthX,
            16,
            'wheat'
        );
        this.wheat.setOrigin(0, 1);
        this.wheat.setScrollFactor(0.575);

        this.ground = this.add.tileSprite
        (
            -worldWidthX,
            this.sys.game.config.height,
            worldWidthX * 3,
            16,
            'ground'
        );

        this.ground.setOrigin(0, 1);
        this.physics.add.existing(this.ground);
        this.ground.body.setImmovable(true);
        this.ground.body.allowGravity = false;
        this.ground.setTint(0xd1e0e0);

        //createLevelProps(this);
        
        this.pipe = this.add.image(15, this.sys.game.config.height - this.ground.height, 'pipe');
        this.pipe.setScrollFactor(0.8);
        this.pipe.setOrigin(0, 1);
       
        
        //END PROPS BEFORE PLAYER Level2Game


        //START PLAYER SETUP Level2Game


        createPlayer(this, 32, this.sys.game.config.height - 24, this.gameManager);
        //this.player.buddha();
        

        //END PLAYER SETUP Level2Game


        //START ENEMY SETUP Level2Game


        if(this.gameManager.level2Data === null)
        {
            this.spawnList = 
            [
                { type: 'cult', amount: getRandMinMax(8, 12) },
                { type: 'cultKnife', amount: getRandMinMax(1, 1) }
            ];

            this.gameManager.level2Data = createRandomEnemies(this, this.spawnList, worldWidthX, this.gameManager);
        }
        else
        { 
            for(const enemy of this.gameManager.level2Data.keys()) 
            {
                if(enemy === 'cult')
                {
                    let enemyData = this.gameManager.level2Data.get(enemy);
                    let enemyPositionArray = enemyData.positions;
                    cultCreator(this, enemyPositionArray, this.gameManager);
                }
                else if(enemy === 'cultKnife')
                {
                    let enemyData = this.gameManager.level2Data.get(enemy);
                    let enemyPositionArray = enemyData.positions;
                    cultKnifeCreator(this, enemyPositionArray, this.gameManager);
                }
            }
        }


        //END ENEMY SETUP Level2Game
        

        //START PROPS AFTER PLAYER Level2Game
        
        
        const thisLevel = 2;
        this.pipe = new pipeNext(this, 2050, this.sys.game.config.height - this.ground.height, 'Level3Game', 2, this.gameManager);

        this.grasstop = this.add.tileSprite
        (
            0,
            this.sys.game.config.height - this.ground.height,
            worldWidthX,
            16,
            'grasstop'
        );
        this.grasstop.setOrigin(0, 1);

        this.physics.add.collider(this.player, this.ground);
        
        makeRain(this, 'raindrop');
        
        filterColors(this, 0xd1e0e0);
        
        
        //END PROPS AFTER PLAYER Level2Game


        //START CAMERA SETUP Level2Game


        this.cameras.main.setBounds(0, 0, worldWidthX, 176);
        this.cameras.main.startFollow(this.player, true, 1, 1, 0, (this.sys.game.config.height / 2));
        this.cameras.main.setZoom(1);
        this.cameras.scrollX = 0;
        this.cameras.scrollY = 0;


        //END CAMERA SETUP Level2Game
    }

    update(time, delta)
    {
        if(this.player.health < 1)
        {
            this.scene.stop('Level2Game');
            this.scene.start('Level1Game');
        }

        cultSeparation(this.cults, this.player);
        //eyeSeparation(this.eyes, this.player);
        
        //activateCultGroups(this, this.cultGroup1); //OLD PRESET
        //activateCultGroups(this, this.cultGroup2);
        //activateCultGroups(this, this.cultGroup3);
    }
  }
  
  
  
  function activateCultGroups(scene, cultGroup)
  {
        scene.cults.children.entries.forEach(cult =>
        {
            if(cult.alert)
            {
                if(cultGroup.has(cult.id))
                {
                    cultGroup.forEach(cultId => 
                    {
                        const cultInstance = scene.cults.children.entries.find(cult => cult.id === cultId);
                        
                        if(cultInstance && !cultInstance.alet) 
                        {
                            cultInstance.alert = true;
                        }
                    });
                }
            }
        });
  }

  class Level3Game extends Phaser.Scene
  {
    constructor()
    {
      super({key: 'Level3Game'});
    }

    create()
    {
        //START BASIC SETUP Level3Game

        
        this.input.setDefaultCursor('');
        const worldWidthX = 1325;
        this.physics.world.setBounds(0, 0, worldWidthX, 176);
        this.cursors = this.input.keyboard.createCursorKeys();
        this.gameManager = this.scene.get('GameManager');
        this.gameManager.updateHighestLevel(3);
        this.gameManager.updateCurrentLevel(3);
        

        //END BASIC SETUP Level3Game


        //START PROPS BEFORE PLAYER Level3Game


        this.sky = this.add.tileSprite(0, 0, worldWidthX, this.sys.game.config.height, 'redskyrain').setOrigin(0, 0);
        this.sky.setScrollFactor(0.1);
        
        if(!this.gameManager.scarecrowPos3)
        {
            let scarePos = getRandomXAnywhere(worldWidthX);
            this.scarecrow = this.add.image(scarePos, this.sys.game.config.height - 16, 'scarecrow').setOrigin(0, 1);
            this.gameManager.scarecrowPos3 = scarePos;
        }
        else
        {
            this.scarecrow = this.add.image(this.gameManager.scarecrowPos3, this.sys.game.config.height - 16, 'scarecrow').setOrigin(0, 1);
        }
        
        this.scarecrow.setScrollFactor(0.4);

        this.wheat = this.add.tileSprite
        (
            0,
            176 - 16,
            worldWidthX,
            16,
            'wheat'
        );
        this.wheat.setOrigin(0, 1);
        this.wheat.setScrollFactor(0.575);

        this.ground = this.add.tileSprite
        (
            -worldWidthX,
            this.sys.game.config.height,
            worldWidthX * 3,
            16,
            'ground'
        );

        this.ground.setOrigin(0, 1);
        this.physics.add.existing(this.ground);
        this.ground.body.setImmovable(true);
        this.ground.body.allowGravity = false;

        this.pipe = this.add.image(15, this.sys.game.config.height - this.ground.height, 'pipe');
        this.pipe.setScrollFactor(0.8);
        this.pipe.setOrigin(0, 1);
     

        //END PROPS BEFORE PLAYER Level3Game


        //START PLAYER SETUP Level3Game


        createPlayer(this, 32, this.sys.game.config.height - 24, this.gameManager);
        //this.player.buddha();
        

        //END PLAYER SETUP Level3Game


        //START ENEMY SETUP Level3Game
        

        if(this.gameManager.level3Data === null)
        {
            this.spawnList = 
            [
                { type: 'cult', amount: getRandMinMax(1, 2) },
                { type: 'cultKnife', amount: getRandMinMax(8, 10) },
                { type: 'eye', amount: getRandMinMax(2, 4) }
            ];

            this.gameManager.level3Data = createRandomEnemies(this, this.spawnList, worldWidthX, this.gameManager);
        }
        else
        { 
            for(const enemy of this.gameManager.level3Data.keys()) 
            {
                if(enemy === 'cult')
                {
                    let enemyData = this.gameManager.level3Data.get(enemy);
                    let enemyPositionArray = enemyData.positions;
                    cultCreator(this, enemyPositionArray, this.gameManager);
                }
                else if(enemy === 'cultKnife')
                {
                    let enemyData = this.gameManager.level3Data.get(enemy);
                    let enemyPositionArray = enemyData.positions;
                    cultKnifeCreator(this, enemyPositionArray, this.gameManager);
                }
                else if(enemy === 'eye')
                {
                    let enemyData = this.gameManager.level3Data.get(enemy);
                    let enemyPositionArray = enemyData.positions;
                    eyeCreator(this, enemyPositionArray, this.gameManager);
                }
            }
        }
        
        
        //END ENEMY SETUP Level3Game
        
        
        //START PROPS AFTER PLAYER Level3Game
        
        
        const thisLevel = 3;
        this.pipe = new pipeNext(this, 1300, this.sys.game.config.height - this.ground.height, 'Level4Game', thisLevel, this.gameManager);

        this.grasstop = this.add.tileSprite
        (
                0,
                this.sys.game.config.height - this.ground.height,
                worldWidthX,
                16,
                'grasstop'
        );
        this.grasstop.setOrigin(0, 1);
        
        this.physics.add.collider(this.player, this.ground);
        
        makeRain(this, 'bloodrain');
        
        filterColors(this, 0xffcccc);
        
        
        //END PROPS AFTER PLAYER Level3Game


        //START CAMERA SETUP Level3Game


        this.cameras.main.setBounds(0, 0, worldWidthX, 176);
        this.cameras.main.startFollow(this.player, true, 1, 1, 0, (this.sys.game.config.height / 2));
        this.cameras.main.setZoom(1);
        this.cameras.scrollX = 0;
        this.cameras.scrollY = 0;


        //END CAMERA SETUP Level3Game
    }
    
    update(time, delta)
    {
      if(this.player.health < 1)
      {
        this.scene.stop('Level3Game');
        this.scene.start('Level2Game');
      }
      
      cultSeparation(this.cults, this.player);
      eyeSeparation(this.eyes, this.player);
    }
  }
  
  class Level4Game extends Phaser.Scene
  {
    constructor()
    {
      super({key: 'Level4Game'});
    }

    create()
    {
        //START BASIC SETUP Level4Game

        
        this.input.setDefaultCursor('');
        const worldWidthX = 2400;
        this.physics.world.setBounds(0, 0, worldWidthX, 176);
        this.cursors = this.input.keyboard.createCursorKeys();
        this.gameManager = this.scene.get('GameManager');
        this.gameManager.updateHighestLevel(4);
        this.gameManager.updateCurrentLevel(4);
        

        //END BASIC SETUP Level4Game


        //START PROPS BEFORE PLAYER Level4Game


        this.sky = this.add.tileSprite(0, 0, worldWidthX, this.sys.game.config.height, 'redsky').setOrigin(0, 0);
        this.sky.setScrollFactor(0.1);
        
        if(!this.gameManager.scarecrowPos4)
        {
            let scarePos = getRandomXAnywhere(worldWidthX);
            this.scarecrow = this.add.image(scarePos, this.sys.game.config.height - 16, 'scarecrow').setOrigin(0, 1);
            this.gameManager.scarecrowPos4 = scarePos;
        }
        else
        {
            this.scarecrow = this.add.image(this.gameManager.scarecrowPos4, this.sys.game.config.height - 16, 'scarecrow').setOrigin(0, 1);
        }
        
        this.scarecrow.setScrollFactor(0.4);

        this.wheat = this.add.tileSprite
        (
            0,
            176 - 16,
            worldWidthX,
            16,
            'wheat'
        );
        this.wheat.setOrigin(0, 1);
        this.wheat.setScrollFactor(0.575);

        this.ground = this.add.tileSprite
        (
                -worldWidthX,
                this.sys.game.config.height,
                worldWidthX * 3,
                16,
                'ground'
        );

        this.ground.setOrigin(0, 1);
        this.physics.add.existing(this.ground);
        this.ground.body.setImmovable(true);
        this.ground.body.allowGravity = false;
        
        this.shed = this.add.image(1557, this.sys.game.config.height - this.ground.height, 'shed');
        this.shed.setOrigin(0, 1);
        this.shed.setScrollFactor(0.65);

        this.fence = this.add.tileSprite
        (
          1748,
          this.sys.game.config.height - this.ground.height,
          200,
          16,
          'fence'
        );
        this.fence.setScrollFactor(0.75);
        this.fence.setOrigin(0, 1);

        this.couch = this.add.image(1921, this.sys.game.config.height - this.ground.height, 'couch');
        this.couch.setScrollFactor(0.8);
        this.couch.setOrigin(0, 1);
        
        this.grill = this.add.image(1967, this.sys.game.config.height - this.ground.height, 'grill');
        this.grill.setScrollFactor(0.8);
        this.grill.setOrigin(0, 1);
        
        this.pipe = this.add.image(15, this.sys.game.config.height - this.ground.height, 'pipe');
        this.pipe.setScrollFactor(0.8);
        this.pipe.setOrigin(0, 1);
     

        //END PROPS BEFORE PLAYER Level4Game


        //START PLAYER SETUP Level4Game


        createPlayer(this, 32, this.sys.game.config.height - 24, this.gameManager);
        //this.player.buddha();
        

        //END PLAYER SETUP Level4Game


        //START ENEMY SETUP Level4Game


        if(this.gameManager.level4Data === null)
        {
            this.spawnList = 
            [
                { type: 'cult', amount: getRandMinMax(19, 21) },
                { type: 'cultKnife', amount: getRandMinMax(4, 5) },
                { type: 'eye', amount: getRandMinMax(6, 8) }
            ];

            this.gameManager.level4Data = createRandomEnemies(this, this.spawnList, worldWidthX, this.gameManager);
        }
        else
        { 
            for(const enemy of this.gameManager.level4Data.keys()) 
            {
                if(enemy === 'cult')
                {
                    let enemyData = this.gameManager.level4Data.get(enemy);
                    let enemyPositionArray = enemyData.positions;
                    cultCreator(this, enemyPositionArray, this.gameManager);
                }
                else if(enemy === 'cultKnife')
                {
                    let enemyData = this.gameManager.level4Data.get(enemy);
                    let enemyPositionArray = enemyData.positions;
                    cultKnifeCreator(this, enemyPositionArray, this.gameManager);
                }
                else if(enemy === 'eye')
                {
                    let enemyData = this.gameManager.level4Data.get(enemy);
                    let enemyPositionArray = enemyData.positions;
                    eyeCreator(this, enemyPositionArray, this.gameManager);
                }
            }
        }
        
        
        //END ENEMY SETUP Level4Game

     
        //START PROPS AFTER PLAYER Level4Game
        
        
        const thisLevel = 4;
        this.pipe = new pipeNext(this, 2225, this.sys.game.config.height - this.ground.height, 'MainMenu', 4, this.gameManager);

        this.grasstop = this.add.tileSprite
        (
                0,
                this.sys.game.config.height - this.ground.height,
                worldWidthX,
                16,
                'grasstop'
        );
        this.grasstop.setOrigin(0, 1);
        
        this.physics.add.collider(this.player, this.ground);
        
        filterColors(this, 0xff9999);
        
        
        //END PROPS AFTER PLAYER Level4Game


        //START CAMERA SETUP Level4Game


        this.cameras.main.setBounds(0, 0, worldWidthX, 176);
        this.cameras.main.startFollow(this.player, true, 1, 1, 0, (this.sys.game.config.height / 2));
        this.cameras.main.setZoom(1);
        this.cameras.scrollX = 0;
        this.cameras.scrollY = 0;


        //END CAMERA SETUP Level4Game
    }
    
    update(time, delta)
    {
      if(this.player.health < 1)
      {
        this.scene.stop('Level4Game');
        this.scene.start('Level3Game');
      }
      
      cultSeparation(this.cults, this.player);
      eyeSeparation(this.eyes, this.player);
      
     // activateCultGroups(this, this.cultGroup1);
      //activateCultGroups(this, this.cultGroup2);
      
      //activateEyeGroups(this, this.eyeGroup1); OLD PRESET UPDATE
      //activateEyeGroups(this, this.eyeGroup2);
    }
  }
  
  function activateEyeGroups(scene, eyeGroup)
  {
        scene.eyes.children.entries.forEach(eye =>
        {
            if(eye.alert)
            {
                if(eyeGroup.has(eye.id))
                {
                    eyeGroup.forEach(eyeId => 
                    {
                        const eyeInstance = scene.eyes.children.entries.find(eye => eye.id === eyeId);
                        
                        if(eyeInstance && !eyeInstance.alet) 
                        {
                            eyeInstance.alert = true;
                        }
                    });
                }
            }
        });
  }
  
  class UpgradeRoom extends Phaser.Scene
  {
    constructor()
    {
        super({key: 'UpgradeRoom'});
        
        this.cardAmount = 8;
        
        this.gameManager = game.scene.getScene('GameManager');
        this.upgradeCardData = this.gameManager.upgradeCardData;
    }

    create()
    {
        this.input.setDefaultCursor('pointer');
        
        
        //START CARD SETUP
        
        
        let card1;
        let card2;
        
        do
        {
            card1 = this.getRandomCardId();
        }
        while(this.gameManager.ownedCards.has(card1))
        
        do
        {
            card2 = this.getRandomCardId();
        }
        while(card2 === card1 || this.gameManager.ownedCards.has(card2) || (this.gameManager.ammoUpgrades.has(card1) && this.gameManager.ammoUpgrades.has(card2)))
    
        this.cardDisplay1 = this.displayCard(card1, 'left');
        this.cardDisplay1.on('pointerdown', () =>
        {
            this.acceptCard(card1);
        });
        
        this.cardDisplay2 = this.displayCard(card2, 'right');
        this.cardDisplay2.on('pointerdown', () =>
        {
            this.acceptCard(card2);
        }); 
        
        
        //END CARD SETUP
    }
    
    update(time, delta)
    {
        
    }
    
    acceptCard(id)
    {
        const card = Object.values(this.upgradeCardData).find(c => c.id === id);
        card.effect(this.gameManager);
        this.gameManager.ownedCards.add(id); 
        transitionLevels(this, this.gameManager);
    }
    
    getRandomCardId()
    {
        return Math.floor(Math.random() * (this.cardAmount - 1 + 1)) + 1;
    }
    
    displayCard(id, position)
    {
        const card = Object.values(this.upgradeCardData).find(c => c.id === id);
        let titleText;
        let descriptionText;
        let icon;
        let xPos;
        const yCenter = this.sys.game.config.height / 2;

        if(position === 'left')
        {
            xPos = this.sys.game.config.width / 4;
        }
        else
        {
            xPos = (this.sys.game.config.width / 4) * 3;
        }
        
        const cardContainer = this.add.container(xPos, yCenter);
        titleText = createText(this, 0, 50, card.name, 20, '#f00').setOrigin(0.5, 0);
        descriptionText = createText(this, 0, -50, card.description, 12, '#f00').setOrigin(0.5, 1);
        descriptionText.setStyle
        ({
            wordWrap: { width: this.sys.game.config.width / 2, use:'true' }
        });
        
        if(card.icon)
        {
            icon = this.add.image
            (
              xPos,
              yCenter,
              card.icon
            ).setOrigin(0.5, 0.5);
        }
        
        cardContainer.add([titleText, descriptionText]);
        
        const hitAreaWidth = this.sys.game.config.width / 2;
        const hitAreaHeight = this.sys.game.config.height;

        const hitArea = new Phaser.Geom.Rectangle
        (
            -hitAreaWidth / 2,
            -hitAreaHeight / 2,
            hitAreaWidth,
            hitAreaHeight
        );

        cardContainer.setInteractive(hitArea, Phaser.Geom.Rectangle.Contains);
        
        return cardContainer;
    }
  }
  
  class GameManager extends Phaser.Scene
  {
    constructor()
    {
        super({ key: 'GameManager' });
        
        this.upgradeCardData = 
        {
            'birdshot': 
            {
                id: 1,
                name: 'Birdshot',
                description: 'Replace shells with Birdshot.',
                icon: 'birdshoticon',
                effect: (gameManager) => 
                {
                    this.clearAmmoOwned();
                    gameManager.fireModeUpgrade = 'birdshot';
                    gameManager.multiAmmoUpgrade = false;
                }
            },
            'slugs': 
            {
                id: 2,
                name: 'Slugs',
                description: 'Replace shells with Slugs.',
                icon: 'slugicon',
                effect: (gameManager) => 
                {
                    this.clearAmmoOwned();
                    gameManager.fireModeUpgrade = 'slug';
                    gameManager.multiAmmoUpgrade = false;
                }
            },
            'damage': 
            {
                id: 3,
                name: 'Gun Oil',
                description: 'Increase Damage by 25%.',
                icon: 'damageicon',
                effect: (gameManager) => 
                {
                    gameManager.damageUpgrade = true;
                }
            },
            'block': 
            {
                id: 4,
                name: 'Refrain',
                description: 'Succesful blocks reset block duration.',
                icon: 'shieldicon',
                effect: (gameManager) => 
                {
                    gameManager.blockUpgrade = true;
                }
                
            },
            'health': 
            {
                id: 5,
                name: 'Conditioning',
                description: 'Survive an extra hit.',
                icon: 'healthicon',
                effect: (gameManager) => 
                {
                    gameManager.healthUpgrade = true;
                }
            },
            'doubleFire': 
            {
                id: 6,
                name: 'Cult Energy',
                description: 'Succesful kills trigger double fire rate.',
                icon: 'cultenergyicon',
                effect: (gameManager) => 
                {
                    gameManager.doubleFireUpgrade = true;
                }
            },
            'pistolDamage': 
            {
                id: 7,
                name: 'Hollow Points',
                description: 'Double handgun damage.',
                icon: 'hollowpointsicon',
                effect: (gameManager) => 
                {
                    gameManager.pistolUpgrade = true;
                }
            },
            'multiAmmo': 
            {
                id: 8,
                name: 'Random Shells',
                description: 'Replace shells with random ones.',
                icon: 'multiammoicon',
                effect: (gameManager) => 
                {
                    this.clearAmmoOwned();
                    gameManager.multiAmmoUpgrade = true;
                }
            }
        };
        
        this.ammoUpgrades = new Set([1, 2, 8]);
        
        this.highestLevel = 0;
        this.initialHighestLevel = this.highestLevel;
        this.currentLevel = 0;
        this.visitedUpgradeRoom1 = false;
        this.visitedUpgradeRoom2 = false;
        this.visitedUpgradeRoom3 = false;
        
        this.ownedCards = new Set();
        
        this.fireModeUpgrade = 'buckshot';
        this.damageUpgrade = false;
        this.blockUpgrade = false;
        this.healthUpgrade = false;
        this.doubleFireUpgrade = false;
        this.pistolUpgrade = false;
        this.multiAmmoUpgrade = false;
        
        this.level1Data = null;
        this.level2Data = null;
        this.level3Data = null;
        this.level4Data = null;
        
        this.scarecrowPos1 = null;
        this.scarecrowPos2 = null;
        this.scarecrowPos3 = null;
        this.scarecrowPos4 = null;
        
        this.alwaysBuddha = false;
    }

    create()
    {
        
    }
    
    update(time, delta)
    {
        
    }
    
    clearAmmoOwned()
    {
        for(const ownedCard of this.ownedCards)
        {
            if(this.ammoUpgrades.has(ownedCard))
            {
                this.ownedCards.delete(ownedCard);
            }
        }
    }
    
    returnCardNameFromId(id)
    {
        const card = Object.values(this.upgradeCardData).find(c => c.id === id);
        return card.name;
    }
    
    updateHighestLevel(newHigh)
    {
        if(newHigh > this.highestLevel)
        {
            this.highestLevel = newHigh;
        }
    }
    
    updateCurrentLevel(newCurrent)
    {
        this.currentLevel = newCurrent;
    }
    
    reset()
    {
        this.highestLevel = 0;
        this.initialHighestLevel = this.highestLevel;
        this.currentLevel = 0;
        this.visitedUpgradeRoom1 = false;
        this.visitedUpgradeRoom2 = false;
        this.visitedUpgradeRoom3 = false;
        
        this.ownedCards = new Set();
        
        this.fireModeUpgrade = 'buckshot';
        this.damageUpgrade = false;
        this.blockUpgrade = false;
        this.healthUpgrade = false;
        this.doubleFireUpgrade = false;
        this.pistolUpgrade = false;
        this.multiAmmoUpgrade = false;
        
        this.level1Data = null;
        this.level2Data = null;
        this.level3Data = null;
        this.level4Data = null;
        
        this.scarecrowPos1 = null;
        this.scarecrowPos2 = null;
        this.scarecrowPos3 = null;
        this.scarecrowPos4 = null;
    }
  }
  
  class HUD extends Phaser.Scene
  {
    constructor()
    {
        super({ key: 'HUD' });
    }
    
    create()
    {
        this.gameManager = this.scene.get('GameManager');
        
        let gap = 0;
        
        for(const ownedCard of this.gameManager.ownedCards)
        {
            createText(this, 6, 6 + gap, this.gameManager.returnCardNameFromId(ownedCard), 14, '#f00').setOrigin(0, 0).setDepth(1232300);
            gap += 20;
        }
    }
    
    update()
    {
        console.log('working hud');
    }
  }
  
  const config =
  {
    type: Phaser.AUTO,
    pixelArt: true,
    width: Math.max(385, Math.min(389, (window.innerWidth / window.innerHeight) * 176)),
    height: 176,
    
    audio:
    {
        pauseOnBlur: true
    },

    scale:
    {
      mode: Phaser.Scale.FIT,
      autoCenter: Phaser.Scale.CENTER_BOTH
    },

    physics:
    {
      default: 'arcade',
      arcade:
      {
        gravity: { y: 300 },
        debug: false
      }
    },

    scene:
    [
      Loading,
      MainMenu,
      GameManager,
      UpgradeRoom,
      Level1Game,
      Level2Game,
      Level3Game,
      Level4Game,
      HUD
    ]
  };

  const game = new Phaser.Game(config);

</script>
</body>
</html>